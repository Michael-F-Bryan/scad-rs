---
source: crates/codegen/src/syntax/ast_nodes.rs
expression: "&formatted"
---
Package = Statement*;

Statement = Include | Use | AssignmentStatement | NamedFunctionDefinition | NamedModuleDefinition | ModuleInstantiation;

Include = 'include' 'file';

Use = 'use' 'file';

AssignmentStatement = Assignment ';';

NamedFunctionDefinition = 'function' 'ident' '(' params:Parameters? ')' '=' body:Expr ';';

NamedModuleDefinition = 'module' 'ident' '(' params:Parameters? ')' body:Statement;

ModuleInstantiation = 'ident' '(' args:Arguments? ')' Child;

Assignment = name:'ident' '=' value:Expr;

Expressions = Expr (',' Expr)*;

Expr = Atom | ListExpression | RangeExpression | UnaryExpr | TernaryExpr | ParenExpr | ListComprehensionExpr | LetClause | BinExpr;

Atom = LiteralExpr | LookupExpr | IndexExpr | FunctionCall;

ListExpression = '[' Expressions ']';

RangeExpression = RangeExpressionFromTo | RangeExpressionFromToStep;

UnaryExpr = ('!' | '+' | '-') Expr;

TernaryExpr = Expr '?' Expr ':' Expr;

ParenExpr = '(' Expr ')';

ListComprehensionExpr = '(' ListComprehensionElements ')';

LetClause = 'let' '(' assignments:AssignmentsOpt ')' ListComprehensionElements Expr;

BinExpr = Expr BinOp Expr;

LiteralExpr = 'true' | 'false' | 'undef' | 'integer' | 'float' | 'string';

LookupExpr = 'ident' ('.' 'ident')*;

IndexExpr = Expr '[' Expr ']';

FunctionCall = 'ident' '(' args:Arguments? ')';

ListComprehensionElements = LetClause | ForClause | IfClause;

BinOp = '+' | '-' | '*' | '/' | '%' | '^' | '>=' | '>' | '=' | '<=' | '<' | '&&' | '||';

RangeExpressionFromTo = '[' Expr ':' Expr ']';

RangeExpressionFromToStep = '[' Expr ':' Expr ':' Expr ']';

ForClause = 'for' '(' assignments:Assignments ')' ListComprehensionElementsOrExpr;

IfClause = 'if' '(' condition:Expr ')' ListComprehensionElementsOrExpr;

ListComprehensionElementsOrExpr = ListComprehensionElements | Expr;

AssignmentsOpt = Assignments?;

Assignments = Assignment (',' Assignment)*;

Parameters = Parameter (',' Parameter)*;

Arguments = Argument (',' Argument)*;

Child = ';' | BracedChildren | ModuleInstantiation;

Children = Child*;

BracedChildren = '{' Children '}';

Parameter = variable:'ident' | Assignment;

Argument = Expr | Assignment;

