// Generated by `scad_codegen::syntax::tests`. DO NOT EDIT!

#![doc = r" Automatically generated, strongly-typed [`AstNode`]s."]
use crate::{OpenSCAD, SyntaxKind};
use rowan::{api::SyntaxNode, ast::AstNode, SyntaxToken};
#[doc = "A strongly typed wrapper around a [`PACKAGE`][SyntaxKind::PACKAGE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Package = Statement*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Package(SyntaxNode<OpenSCAD>);
impl AstNode for Package {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::PACKAGE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Package::can_cast(node.kind()) {
            Some(Package(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Package {
    pub fn statements(&self) -> impl Iterator<Item = Statement> {
        self.0.children().filter_map(Statement::cast)
    }
}
#[doc = "A strongly typed `Statement` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Statement = Include | Use | AssignmentStatement | NamedFunctionDefinition | NamedModuleDefinition | ModuleInstantiation | IfStatement;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Statement {
    Include(Include),
    Use(Use),
    AssignmentStatement(AssignmentStatement),
    NamedFunctionDefinition(NamedFunctionDefinition),
    NamedModuleDefinition(NamedModuleDefinition),
    ModuleInstantiation(ModuleInstantiation),
    IfStatement(IfStatement),
}
impl AstNode for Statement {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        Include::can_cast(kind)
            || Use::can_cast(kind)
            || AssignmentStatement::can_cast(kind)
            || NamedFunctionDefinition::can_cast(kind)
            || NamedModuleDefinition::can_cast(kind)
            || ModuleInstantiation::can_cast(kind)
            || IfStatement::can_cast(kind)
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = Include::cast(node.clone()) {
            return Some(Statement::Include(variant));
        }
        if let Some(variant) = Use::cast(node.clone()) {
            return Some(Statement::Use(variant));
        }
        if let Some(variant) = AssignmentStatement::cast(node.clone()) {
            return Some(Statement::AssignmentStatement(variant));
        }
        if let Some(variant) = NamedFunctionDefinition::cast(node.clone()) {
            return Some(Statement::NamedFunctionDefinition(variant));
        }
        if let Some(variant) = NamedModuleDefinition::cast(node.clone()) {
            return Some(Statement::NamedModuleDefinition(variant));
        }
        if let Some(variant) = ModuleInstantiation::cast(node.clone()) {
            return Some(Statement::ModuleInstantiation(variant));
        }
        if let Some(variant) = IfStatement::cast(node.clone()) {
            return Some(Statement::IfStatement(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            Statement::Include(node) => node.syntax(),
            Statement::Use(node) => node.syntax(),
            Statement::AssignmentStatement(node) => node.syntax(),
            Statement::NamedFunctionDefinition(node) => node.syntax(),
            Statement::NamedModuleDefinition(node) => node.syntax(),
            Statement::ModuleInstantiation(node) => node.syntax(),
            Statement::IfStatement(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`INCLUDE`][SyntaxKind::INCLUDE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Include = 'include' 'file';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Include(SyntaxNode<OpenSCAD>);
impl AstNode for Include {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::INCLUDE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Include::can_cast(node.kind()) {
            Some(Include(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Include {
    pub fn include_kw_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::INCLUDE_KW)
    }
    pub fn file_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::FILE)
    }
}
#[doc = "A strongly typed wrapper around a [`USE`][SyntaxKind::USE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Use = 'use' 'file';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Use(SyntaxNode<OpenSCAD>);
impl AstNode for Use {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::USE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Use::can_cast(node.kind()) {
            Some(Use(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Use {
    pub fn use_kw_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::USE_KW)
    }
    pub fn file_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::FILE)
    }
}
#[doc = "A strongly typed wrapper around a [`ASSIGNMENT_STATEMENT`][SyntaxKind::ASSIGNMENT_STATEMENT] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "AssignmentStatement = Assignment ';';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignmentStatement(SyntaxNode<OpenSCAD>);
impl AstNode for AssignmentStatement {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ASSIGNMENT_STATEMENT
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if AssignmentStatement::can_cast(node.kind()) {
            Some(AssignmentStatement(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl AssignmentStatement {
    pub fn assignment(&self) -> Option<Assignment> {
        self.0.children().find_map(Assignment::cast)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::SEMICOLON)
    }
}
#[doc = "A strongly typed wrapper around a [`NAMED_FUNCTION_DEFINITION`][SyntaxKind::NAMED_FUNCTION_DEFINITION] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "NamedFunctionDefinition = 'function' 'ident' '(' params:Parameters? ')' '=' body:Expr ';';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFunctionDefinition(SyntaxNode<OpenSCAD>);
impl AstNode for NamedFunctionDefinition {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::NAMED_FUNCTION_DEFINITION
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if NamedFunctionDefinition::can_cast(node.kind()) {
            Some(NamedFunctionDefinition(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl NamedFunctionDefinition {
    pub fn function_kw_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::FUNCTION_KW)
    }
    pub fn ident_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IDENT)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn parameters_opt(&self) -> Option<Parameters> {
        self.0.children().find_map(Parameters::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn equals_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::EQUALS)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::SEMICOLON)
    }
}
#[doc = "A strongly typed wrapper around a [`NAMED_MODULE_DEFINITION`][SyntaxKind::NAMED_MODULE_DEFINITION] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "NamedModuleDefinition = 'module' 'ident' '(' params:Parameters? ')' '{' body:Statement* '}';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedModuleDefinition(SyntaxNode<OpenSCAD>);
impl AstNode for NamedModuleDefinition {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::NAMED_MODULE_DEFINITION
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if NamedModuleDefinition::can_cast(node.kind()) {
            Some(NamedModuleDefinition(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl NamedModuleDefinition {
    pub fn module_kw_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::MODULE_KW)
    }
    pub fn ident_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IDENT)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn parameters_opt(&self) -> Option<Parameters> {
        self.0.children().find_map(Parameters::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_CURLY)
    }
    pub fn statements(&self) -> impl Iterator<Item = Statement> {
        self.0.children().filter_map(Statement::cast)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_CURLY)
    }
}
#[doc = "A strongly typed wrapper around a [`MODULE_INSTANTIATION`][SyntaxKind::MODULE_INSTANTIATION] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ModuleInstantiation = 'ident' '(' args:Arguments? ')' Child;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuleInstantiation(SyntaxNode<OpenSCAD>);
impl AstNode for ModuleInstantiation {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::MODULE_INSTANTIATION
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if ModuleInstantiation::can_cast(node.kind()) {
            Some(ModuleInstantiation(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl ModuleInstantiation {
    pub fn ident_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IDENT)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn arguments_opt(&self) -> Option<Arguments> {
        self.0.children().find_map(Arguments::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn child(&self) -> Option<Child> {
        self.0.children().find_map(Child::cast)
    }
}
#[doc = "A strongly typed wrapper around a [`IF_STATEMENT`][SyntaxKind::IF_STATEMENT] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "IfStatement = 'if' '(' Expr ')' Actions ('else' Actions)?;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfStatement(SyntaxNode<OpenSCAD>);
impl AstNode for IfStatement {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::IF_STATEMENT
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if IfStatement::can_cast(node.kind()) {
            Some(IfStatement(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl IfStatement {
    pub fn if_kw_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IF_KW)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn actions(&self) -> impl Iterator<Item = Actions> {
        self.0.children().filter_map(Actions::cast)
    }
    pub fn else_kw_token_opt(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::ELSE_KW)
    }
}
#[doc = "A strongly typed `Expr` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Expr = Atom | ListExpr | RangeExpr | UnaryExpr | TernaryExpr | ParenExpr | ListComprehensionExpr | BinExpr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    Atom(Atom),
    ListExpr(ListExpr),
    RangeExpr(RangeExpr),
    UnaryExpr(UnaryExpr),
    TernaryExpr(TernaryExpr),
    ParenExpr(ParenExpr),
    ListComprehensionExpr(ListComprehensionExpr),
    BinExpr(BinExpr),
}
impl AstNode for Expr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        Atom::can_cast(kind)
            || ListExpr::can_cast(kind)
            || RangeExpr::can_cast(kind)
            || UnaryExpr::can_cast(kind)
            || TernaryExpr::can_cast(kind)
            || ParenExpr::can_cast(kind)
            || ListComprehensionExpr::can_cast(kind)
            || BinExpr::can_cast(kind)
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = Atom::cast(node.clone()) {
            return Some(Expr::Atom(variant));
        }
        if let Some(variant) = ListExpr::cast(node.clone()) {
            return Some(Expr::ListExpr(variant));
        }
        if let Some(variant) = RangeExpr::cast(node.clone()) {
            return Some(Expr::RangeExpr(variant));
        }
        if let Some(variant) = UnaryExpr::cast(node.clone()) {
            return Some(Expr::UnaryExpr(variant));
        }
        if let Some(variant) = TernaryExpr::cast(node.clone()) {
            return Some(Expr::TernaryExpr(variant));
        }
        if let Some(variant) = ParenExpr::cast(node.clone()) {
            return Some(Expr::ParenExpr(variant));
        }
        if let Some(variant) = ListComprehensionExpr::cast(node.clone()) {
            return Some(Expr::ListComprehensionExpr(variant));
        }
        if let Some(variant) = BinExpr::cast(node.clone()) {
            return Some(Expr::BinExpr(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            Expr::Atom(node) => node.syntax(),
            Expr::ListExpr(node) => node.syntax(),
            Expr::RangeExpr(node) => node.syntax(),
            Expr::UnaryExpr(node) => node.syntax(),
            Expr::TernaryExpr(node) => node.syntax(),
            Expr::ParenExpr(node) => node.syntax(),
            Expr::ListComprehensionExpr(node) => node.syntax(),
            Expr::BinExpr(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed `Actions` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Actions = Action | BracedActions;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Actions {
    Action(Action),
    BracedActions(BracedActions),
}
impl AstNode for Actions {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        Action::can_cast(kind) || BracedActions::can_cast(kind)
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = Action::cast(node.clone()) {
            return Some(Actions::Action(variant));
        }
        if let Some(variant) = BracedActions::cast(node.clone()) {
            return Some(Actions::BracedActions(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            Actions::Action(node) => node.syntax(),
            Actions::BracedActions(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed `Action` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Action = AssignmentStatement | ModuleInstantiation | IfStatement;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Action {
    AssignmentStatement(AssignmentStatement),
    ModuleInstantiation(ModuleInstantiation),
    IfStatement(IfStatement),
}
impl AstNode for Action {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        AssignmentStatement::can_cast(kind)
            || ModuleInstantiation::can_cast(kind)
            || IfStatement::can_cast(kind)
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = AssignmentStatement::cast(node.clone()) {
            return Some(Action::AssignmentStatement(variant));
        }
        if let Some(variant) = ModuleInstantiation::cast(node.clone()) {
            return Some(Action::ModuleInstantiation(variant));
        }
        if let Some(variant) = IfStatement::cast(node.clone()) {
            return Some(Action::IfStatement(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            Action::AssignmentStatement(node) => node.syntax(),
            Action::ModuleInstantiation(node) => node.syntax(),
            Action::IfStatement(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`BRACED_ACTIONS`][SyntaxKind::BRACED_ACTIONS] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "BracedActions = '{' Action* '}';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BracedActions(SyntaxNode<OpenSCAD>);
impl AstNode for BracedActions {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::BRACED_ACTIONS
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if BracedActions::can_cast(node.kind()) {
            Some(BracedActions(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl BracedActions {
    pub fn l_curly_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_CURLY)
    }
    pub fn actions(&self) -> impl Iterator<Item = Action> {
        self.0.children().filter_map(Action::cast)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_CURLY)
    }
}
#[doc = "A strongly typed wrapper around a [`ASSIGNMENT`][SyntaxKind::ASSIGNMENT] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Assignment = name:'ident' '=' value:Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Assignment(SyntaxNode<OpenSCAD>);
impl AstNode for Assignment {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ASSIGNMENT
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Assignment::can_cast(node.kind()) {
            Some(Assignment(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Assignment {
    pub fn ident_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IDENT)
    }
    pub fn equals_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::EQUALS)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
}
#[doc = "A strongly typed wrapper around a [`EXPRESSIONS`][SyntaxKind::EXPRESSIONS] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Expressions = Expr (',' Expr)*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Expressions(SyntaxNode<OpenSCAD>);
impl AstNode for Expressions {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::EXPRESSIONS
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Expressions::can_cast(node.kind()) {
            Some(Expressions(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Expressions {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn comma_tokens(&self) -> impl Iterator<Item = SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::COMMA)
    }
}
#[doc = "A strongly typed `Atom` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Atom = LiteralExpr | LookupExpr | IndexExpr | FunctionCall;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Atom {
    LiteralExpr(LiteralExpr),
    LookupExpr(LookupExpr),
    IndexExpr(IndexExpr),
    FunctionCall(FunctionCall),
}
impl AstNode for Atom {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        LiteralExpr::can_cast(kind)
            || LookupExpr::can_cast(kind)
            || IndexExpr::can_cast(kind)
            || FunctionCall::can_cast(kind)
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = LiteralExpr::cast(node.clone()) {
            return Some(Atom::LiteralExpr(variant));
        }
        if let Some(variant) = LookupExpr::cast(node.clone()) {
            return Some(Atom::LookupExpr(variant));
        }
        if let Some(variant) = IndexExpr::cast(node.clone()) {
            return Some(Atom::IndexExpr(variant));
        }
        if let Some(variant) = FunctionCall::cast(node.clone()) {
            return Some(Atom::FunctionCall(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            Atom::LiteralExpr(node) => node.syntax(),
            Atom::LookupExpr(node) => node.syntax(),
            Atom::IndexExpr(node) => node.syntax(),
            Atom::FunctionCall(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`LIST_EXPR`][SyntaxKind::LIST_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ListExpr = '[' Expressions ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListExpr(SyntaxNode<OpenSCAD>);
impl AstNode for ListExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::LIST_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if ListExpr::can_cast(node.kind()) {
            Some(ListExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl ListExpr {
    pub fn l_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_BRACKET)
    }
    pub fn expressions(&self) -> Option<Expressions> {
        self.0.children().find_map(Expressions::cast)
    }
    pub fn r_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_BRACKET)
    }
}
#[doc = "A strongly typed `RangeExpr` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "RangeExpr = RangeExprFromTo | RangeExprFromToStep;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RangeExpr {
    RangeExprFromTo(RangeExprFromTo),
    RangeExprFromToStep(RangeExprFromToStep),
}
impl AstNode for RangeExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        RangeExprFromTo::can_cast(kind) || RangeExprFromToStep::can_cast(kind)
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = RangeExprFromTo::cast(node.clone()) {
            return Some(RangeExpr::RangeExprFromTo(variant));
        }
        if let Some(variant) = RangeExprFromToStep::cast(node.clone()) {
            return Some(RangeExpr::RangeExprFromToStep(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            RangeExpr::RangeExprFromTo(node) => node.syntax(),
            RangeExpr::RangeExprFromToStep(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`UNARY_EXPR`][SyntaxKind::UNARY_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "UnaryExpr = ('!' | '+' | '-') Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnaryExpr(SyntaxNode<OpenSCAD>);
impl AstNode for UnaryExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::UNARY_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if UnaryExpr::can_cast(node.kind()) {
            Some(UnaryExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl UnaryExpr {
    pub fn bang_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::BANG)
    }
    pub fn plus_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::PLUS)
    }
    pub fn minus_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::MINUS)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
}
#[doc = "A strongly typed wrapper around a [`TERNARY_EXPR`][SyntaxKind::TERNARY_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "TernaryExpr = Expr '?' Expr ':' Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TernaryExpr(SyntaxNode<OpenSCAD>);
impl AstNode for TernaryExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::TERNARY_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if TernaryExpr::can_cast(node.kind()) {
            Some(TernaryExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl TernaryExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn question_mark_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::QUESTION_MARK)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::COLON)
    }
}
#[doc = "A strongly typed wrapper around a [`PAREN_EXPR`][SyntaxKind::PAREN_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ParenExpr = '(' Expr ')';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr(SyntaxNode<OpenSCAD>);
impl AstNode for ParenExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::PAREN_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if ParenExpr::can_cast(node.kind()) {
            Some(ParenExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl ParenExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
}
#[doc = "A strongly typed wrapper around a [`LIST_COMPREHENSION_EXPR`][SyntaxKind::LIST_COMPREHENSION_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ListComprehensionExpr = '[' ForClause ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListComprehensionExpr(SyntaxNode<OpenSCAD>);
impl AstNode for ListComprehensionExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::LIST_COMPREHENSION_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if ListComprehensionExpr::can_cast(node.kind()) {
            Some(ListComprehensionExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl ListComprehensionExpr {
    pub fn l_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_BRACKET)
    }
    pub fn for_clause(&self) -> Option<ForClause> {
        self.0.children().find_map(ForClause::cast)
    }
    pub fn r_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_BRACKET)
    }
}
#[doc = "A strongly typed wrapper around a [`BIN_EXPR`][SyntaxKind::BIN_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "BinExpr = Expr BinOp Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr(SyntaxNode<OpenSCAD>);
impl AstNode for BinExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::BIN_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if BinExpr::can_cast(node.kind()) {
            Some(BinExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl BinExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn bin_op(&self) -> Option<BinOp> {
        self.0.children().find_map(BinOp::cast)
    }
}
#[doc = "A strongly typed `LiteralExpr` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "LiteralExpr = 'true' | 'false' | 'undef' | 'integer' | 'float' | 'string';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum LiteralExpr {
    TrueKw(SyntaxNode<OpenSCAD>),
    FalseKw(SyntaxNode<OpenSCAD>),
    UndefKw(SyntaxNode<OpenSCAD>),
    Integer(SyntaxNode<OpenSCAD>),
    Float(SyntaxNode<OpenSCAD>),
    String(SyntaxNode<OpenSCAD>),
}
impl AstNode for LiteralExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::TRUE_KW
            || kind == SyntaxKind::FALSE_KW
            || kind == SyntaxKind::UNDEF_KW
            || kind == SyntaxKind::INTEGER
            || kind == SyntaxKind::FLOAT
            || kind == SyntaxKind::STRING
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if node.kind() == SyntaxKind::TRUE_KW {
            return Some(LiteralExpr::TrueKw(node));
        }
        if node.kind() == SyntaxKind::FALSE_KW {
            return Some(LiteralExpr::FalseKw(node));
        }
        if node.kind() == SyntaxKind::UNDEF_KW {
            return Some(LiteralExpr::UndefKw(node));
        }
        if node.kind() == SyntaxKind::INTEGER {
            return Some(LiteralExpr::Integer(node));
        }
        if node.kind() == SyntaxKind::FLOAT {
            return Some(LiteralExpr::Float(node));
        }
        if node.kind() == SyntaxKind::STRING {
            return Some(LiteralExpr::String(node));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            LiteralExpr::TrueKw(node) => node,
            LiteralExpr::FalseKw(node) => node,
            LiteralExpr::UndefKw(node) => node,
            LiteralExpr::Integer(node) => node,
            LiteralExpr::Float(node) => node,
            LiteralExpr::String(node) => node,
        }
    }
}
#[doc = "A strongly typed wrapper around a [`LOOKUP_EXPR`][SyntaxKind::LOOKUP_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "LookupExpr = 'ident' ('.' 'ident')*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LookupExpr(SyntaxNode<OpenSCAD>);
impl AstNode for LookupExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::LOOKUP_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if LookupExpr::can_cast(node.kind()) {
            Some(LookupExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl LookupExpr {
    pub fn ident_tokens(&self) -> impl Iterator<Item = SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::IDENT)
    }
    pub fn dot_tokens(&self) -> impl Iterator<Item = SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::DOT)
    }
}
#[doc = "A strongly typed wrapper around a [`INDEX_EXPR`][SyntaxKind::INDEX_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "IndexExpr = Expr '[' Expr ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr(SyntaxNode<OpenSCAD>);
impl AstNode for IndexExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::INDEX_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if IndexExpr::can_cast(node.kind()) {
            Some(IndexExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl IndexExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn l_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_BRACKET)
    }
    pub fn r_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_BRACKET)
    }
}
#[doc = "A strongly typed wrapper around a [`FUNCTION_CALL`][SyntaxKind::FUNCTION_CALL] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "FunctionCall = 'ident' '(' args:Arguments? ')';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionCall(SyntaxNode<OpenSCAD>);
impl AstNode for FunctionCall {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::FUNCTION_CALL
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if FunctionCall::can_cast(node.kind()) {
            Some(FunctionCall(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl FunctionCall {
    pub fn ident_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IDENT)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn arguments_opt(&self) -> Option<Arguments> {
        self.0.children().find_map(Arguments::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
}
#[doc = "A strongly typed wrapper around a [`FOR_CLAUSE`][SyntaxKind::FOR_CLAUSE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ForClause = 'for' '(' assignments:Assignments ')' ListComprehensionElementOrExpr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForClause(SyntaxNode<OpenSCAD>);
impl AstNode for ForClause {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::FOR_CLAUSE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if ForClause::can_cast(node.kind()) {
            Some(ForClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl ForClause {
    pub fn for_kw_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::FOR_KW)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn assignments(&self) -> Option<Assignments> {
        self.0.children().find_map(Assignments::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn list_comprehension_element_or_expr(&self) -> Option<ListComprehensionElementOrExpr> {
        self.0
            .children()
            .find_map(ListComprehensionElementOrExpr::cast)
    }
}
#[doc = "A strongly typed `BinOp` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "BinOp = '+' | '-' | '*' | '/' | '%' | '^' | '>=' | '>' | '==' | '<=' | '<' | '&&' | '||';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum BinOp {
    Plus(SyntaxNode<OpenSCAD>),
    Minus(SyntaxNode<OpenSCAD>),
    Star(SyntaxNode<OpenSCAD>),
    Slash(SyntaxNode<OpenSCAD>),
    Percent(SyntaxNode<OpenSCAD>),
    Caret(SyntaxNode<OpenSCAD>),
    GreaterThanEquals(SyntaxNode<OpenSCAD>),
    GreaterThan(SyntaxNode<OpenSCAD>),
    DoubleEquals(SyntaxNode<OpenSCAD>),
    LessThanEquals(SyntaxNode<OpenSCAD>),
    LessThan(SyntaxNode<OpenSCAD>),
    And(SyntaxNode<OpenSCAD>),
    Or(SyntaxNode<OpenSCAD>),
}
impl AstNode for BinOp {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::PLUS
            || kind == SyntaxKind::MINUS
            || kind == SyntaxKind::STAR
            || kind == SyntaxKind::SLASH
            || kind == SyntaxKind::PERCENT
            || kind == SyntaxKind::CARET
            || kind == SyntaxKind::GREATER_THAN_EQUALS
            || kind == SyntaxKind::GREATER_THAN
            || kind == SyntaxKind::DOUBLE_EQUALS
            || kind == SyntaxKind::LESS_THAN_EQUALS
            || kind == SyntaxKind::LESS_THAN
            || kind == SyntaxKind::AND
            || kind == SyntaxKind::OR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if node.kind() == SyntaxKind::PLUS {
            return Some(BinOp::Plus(node));
        }
        if node.kind() == SyntaxKind::MINUS {
            return Some(BinOp::Minus(node));
        }
        if node.kind() == SyntaxKind::STAR {
            return Some(BinOp::Star(node));
        }
        if node.kind() == SyntaxKind::SLASH {
            return Some(BinOp::Slash(node));
        }
        if node.kind() == SyntaxKind::PERCENT {
            return Some(BinOp::Percent(node));
        }
        if node.kind() == SyntaxKind::CARET {
            return Some(BinOp::Caret(node));
        }
        if node.kind() == SyntaxKind::GREATER_THAN_EQUALS {
            return Some(BinOp::GreaterThanEquals(node));
        }
        if node.kind() == SyntaxKind::GREATER_THAN {
            return Some(BinOp::GreaterThan(node));
        }
        if node.kind() == SyntaxKind::DOUBLE_EQUALS {
            return Some(BinOp::DoubleEquals(node));
        }
        if node.kind() == SyntaxKind::LESS_THAN_EQUALS {
            return Some(BinOp::LessThanEquals(node));
        }
        if node.kind() == SyntaxKind::LESS_THAN {
            return Some(BinOp::LessThan(node));
        }
        if node.kind() == SyntaxKind::AND {
            return Some(BinOp::And(node));
        }
        if node.kind() == SyntaxKind::OR {
            return Some(BinOp::Or(node));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            BinOp::Plus(node) => node,
            BinOp::Minus(node) => node,
            BinOp::Star(node) => node,
            BinOp::Slash(node) => node,
            BinOp::Percent(node) => node,
            BinOp::Caret(node) => node,
            BinOp::GreaterThanEquals(node) => node,
            BinOp::GreaterThan(node) => node,
            BinOp::DoubleEquals(node) => node,
            BinOp::LessThanEquals(node) => node,
            BinOp::LessThan(node) => node,
            BinOp::And(node) => node,
            BinOp::Or(node) => node,
        }
    }
}
#[doc = "A strongly typed wrapper around a [`RANGE_EXPR_FROM_TO`][SyntaxKind::RANGE_EXPR_FROM_TO] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "RangeExprFromTo = '[' Expr ':' Expr ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExprFromTo(SyntaxNode<OpenSCAD>);
impl AstNode for RangeExprFromTo {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::RANGE_EXPR_FROM_TO
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if RangeExprFromTo::can_cast(node.kind()) {
            Some(RangeExprFromTo(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl RangeExprFromTo {
    pub fn l_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_BRACKET)
    }
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::COLON)
    }
    pub fn r_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_BRACKET)
    }
}
#[doc = "A strongly typed wrapper around a [`RANGE_EXPR_FROM_TO_STEP`][SyntaxKind::RANGE_EXPR_FROM_TO_STEP] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "RangeExprFromToStep = '[' Expr ':' Expr ':' Expr ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExprFromToStep(SyntaxNode<OpenSCAD>);
impl AstNode for RangeExprFromToStep {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::RANGE_EXPR_FROM_TO_STEP
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if RangeExprFromToStep::can_cast(node.kind()) {
            Some(RangeExprFromToStep(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl RangeExprFromToStep {
    pub fn l_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_BRACKET)
    }
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn colon_tokens(&self) -> impl Iterator<Item = SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::COLON)
    }
    pub fn r_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_BRACKET)
    }
}
#[doc = "A strongly typed `ListComprehensionElement` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ListComprehensionElement = LetClause | ForClause | IfClause;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ListComprehensionElement {
    LetClause(LetClause),
    ForClause(ForClause),
    IfClause(IfClause),
}
impl AstNode for ListComprehensionElement {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        LetClause::can_cast(kind) || ForClause::can_cast(kind) || IfClause::can_cast(kind)
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = LetClause::cast(node.clone()) {
            return Some(ListComprehensionElement::LetClause(variant));
        }
        if let Some(variant) = ForClause::cast(node.clone()) {
            return Some(ListComprehensionElement::ForClause(variant));
        }
        if let Some(variant) = IfClause::cast(node.clone()) {
            return Some(ListComprehensionElement::IfClause(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            ListComprehensionElement::LetClause(node) => node.syntax(),
            ListComprehensionElement::ForClause(node) => node.syntax(),
            ListComprehensionElement::IfClause(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`LET_CLAUSE`][SyntaxKind::LET_CLAUSE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "LetClause = 'let' '(' assignments:AssignmentsOpt ')' ListComprehensionElementOrExpr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetClause(SyntaxNode<OpenSCAD>);
impl AstNode for LetClause {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::LET_CLAUSE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if LetClause::can_cast(node.kind()) {
            Some(LetClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl LetClause {
    pub fn let_kw_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::LET_KW)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn assignments_opt(&self) -> Option<AssignmentsOpt> {
        self.0.children().find_map(AssignmentsOpt::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn list_comprehension_element_or_expr(&self) -> Option<ListComprehensionElementOrExpr> {
        self.0
            .children()
            .find_map(ListComprehensionElementOrExpr::cast)
    }
}
#[doc = "A strongly typed wrapper around a [`IF_CLAUSE`][SyntaxKind::IF_CLAUSE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "IfClause = 'if' '(' condition:Expr ')' ListComprehensionElementOrExpr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfClause(SyntaxNode<OpenSCAD>);
impl AstNode for IfClause {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::IF_CLAUSE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if IfClause::can_cast(node.kind()) {
            Some(IfClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl IfClause {
    pub fn if_kw_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IF_KW)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn list_comprehension_element_or_expr(&self) -> Option<ListComprehensionElementOrExpr> {
        self.0
            .children()
            .find_map(ListComprehensionElementOrExpr::cast)
    }
}
#[doc = "A strongly typed `ListComprehensionElementOrExpr` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ListComprehensionElementOrExpr = ListComprehensionElement | Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ListComprehensionElementOrExpr {
    ListComprehensionElement(ListComprehensionElement),
    Expr(Expr),
}
impl AstNode for ListComprehensionElementOrExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        ListComprehensionElement::can_cast(kind) || Expr::can_cast(kind)
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = ListComprehensionElement::cast(node.clone()) {
            return Some(ListComprehensionElementOrExpr::ListComprehensionElement(
                variant,
            ));
        }
        if let Some(variant) = Expr::cast(node.clone()) {
            return Some(ListComprehensionElementOrExpr::Expr(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            ListComprehensionElementOrExpr::ListComprehensionElement(node) => node.syntax(),
            ListComprehensionElementOrExpr::Expr(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`ASSIGNMENTS_OPT`][SyntaxKind::ASSIGNMENTS_OPT] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "AssignmentsOpt = Assignments?;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignmentsOpt(SyntaxNode<OpenSCAD>);
impl AstNode for AssignmentsOpt {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ASSIGNMENTS_OPT
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if AssignmentsOpt::can_cast(node.kind()) {
            Some(AssignmentsOpt(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl AssignmentsOpt {
    pub fn assignments_opt(&self) -> Option<Assignments> {
        self.0.children().find_map(Assignments::cast)
    }
}
#[doc = "A strongly typed wrapper around a [`ASSIGNMENTS`][SyntaxKind::ASSIGNMENTS] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Assignments = Assignment (',' Assignment)*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Assignments(SyntaxNode<OpenSCAD>);
impl AstNode for Assignments {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ASSIGNMENTS
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Assignments::can_cast(node.kind()) {
            Some(Assignments(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Assignments {
    pub fn assignments(&self) -> impl Iterator<Item = Assignment> {
        self.0.children().filter_map(Assignment::cast)
    }
    pub fn comma_tokens(&self) -> impl Iterator<Item = SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::COMMA)
    }
}
#[doc = "A strongly typed wrapper around a [`PARAMETERS`][SyntaxKind::PARAMETERS] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Parameters = Parameter (',' Parameter)*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Parameters(SyntaxNode<OpenSCAD>);
impl AstNode for Parameters {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::PARAMETERS
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Parameters::can_cast(node.kind()) {
            Some(Parameters(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Parameters {
    pub fn parameters(&self) -> impl Iterator<Item = Parameter> {
        self.0.children().filter_map(Parameter::cast)
    }
    pub fn comma_tokens(&self) -> impl Iterator<Item = SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::COMMA)
    }
}
#[doc = "A strongly typed wrapper around a [`ARGUMENTS`][SyntaxKind::ARGUMENTS] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Arguments = Argument (',' Argument)*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Arguments(SyntaxNode<OpenSCAD>);
impl AstNode for Arguments {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ARGUMENTS
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Arguments::can_cast(node.kind()) {
            Some(Arguments(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Arguments {
    pub fn arguments(&self) -> impl Iterator<Item = Argument> {
        self.0.children().filter_map(Argument::cast)
    }
    pub fn comma_tokens(&self) -> impl Iterator<Item = SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::COMMA)
    }
}
#[doc = "A strongly typed `Child` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Child = ';' | BracedChildren | ModuleInstantiation;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Child {
    Semicolon(SyntaxNode<OpenSCAD>),
    BracedChildren(BracedChildren),
    ModuleInstantiation(ModuleInstantiation),
}
impl AstNode for Child {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::SEMICOLON
            || BracedChildren::can_cast(kind)
            || ModuleInstantiation::can_cast(kind)
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if node.kind() == SyntaxKind::SEMICOLON {
            return Some(Child::Semicolon(node));
        }
        if let Some(variant) = BracedChildren::cast(node.clone()) {
            return Some(Child::BracedChildren(variant));
        }
        if let Some(variant) = ModuleInstantiation::cast(node.clone()) {
            return Some(Child::ModuleInstantiation(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            Child::Semicolon(node) => node,
            Child::BracedChildren(node) => node.syntax(),
            Child::ModuleInstantiation(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`CHILDREN`][SyntaxKind::CHILDREN] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Children = Child*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Children(SyntaxNode<OpenSCAD>);
impl AstNode for Children {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::CHILDREN
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Children::can_cast(node.kind()) {
            Some(Children(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Children {
    pub fn childs(&self) -> impl Iterator<Item = Child> {
        self.0.children().filter_map(Child::cast)
    }
}
#[doc = "A strongly typed wrapper around a [`BRACED_CHILDREN`][SyntaxKind::BRACED_CHILDREN] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "BracedChildren = '{' Children '}';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BracedChildren(SyntaxNode<OpenSCAD>);
impl AstNode for BracedChildren {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::BRACED_CHILDREN
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if BracedChildren::can_cast(node.kind()) {
            Some(BracedChildren(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl BracedChildren {
    pub fn l_curly_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_CURLY)
    }
    pub fn children(&self) -> Option<Children> {
        self.0.children().find_map(Children::cast)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_CURLY)
    }
}
#[doc = "A strongly typed `Parameter` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Parameter = variable:'ident' | Assignment;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Parameter {
    Ident(SyntaxNode<OpenSCAD>),
    Assignment(Assignment),
}
impl AstNode for Parameter {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::IDENT || Assignment::can_cast(kind)
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if node.kind() == SyntaxKind::IDENT {
            return Some(Parameter::Ident(node));
        }
        if let Some(variant) = Assignment::cast(node.clone()) {
            return Some(Parameter::Assignment(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            Parameter::Ident(node) => node,
            Parameter::Assignment(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed `Argument` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Argument = Expr | Assignment;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Argument {
    Expr(Expr),
    Assignment(Assignment),
}
impl AstNode for Argument {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        Expr::can_cast(kind) || Assignment::can_cast(kind)
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = Expr::cast(node.clone()) {
            return Some(Argument::Expr(variant));
        }
        if let Some(variant) = Assignment::cast(node.clone()) {
            return Some(Argument::Assignment(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            Argument::Expr(node) => node.syntax(),
            Argument::Assignment(node) => node.syntax(),
        }
    }
}
