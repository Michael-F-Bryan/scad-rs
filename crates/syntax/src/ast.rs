// Generated by `scad-codegen`. DO NOT EDIT!

pub struct Package(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Package {
    pub fn statements(&self) -> impl Iterator<Item = Statement> {
        self.0
            .children()
            .filter_map(<Statement as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for Package {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::PACKAGE
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Package::can_cast(node.kind()) {
            Some(Package(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct Include(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Include {}
impl rowan::ast::AstNode for Include {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::INCLUDE
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Include::can_cast(node.kind()) {
            Some(Include(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct Use(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Use {}
impl rowan::ast::AstNode for Use {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::USE
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Use::can_cast(node.kind()) {
            Some(Use(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct Assignment(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Assignment {
    pub fn value(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for Assignment {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::ASSIGNMENT
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Assignment::can_cast(node.kind()) {
            Some(Assignment(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct NamedFunctionDefinition(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl NamedFunctionDefinition {
    pub fn params_opt(&self) -> Option<Parameters> {
        self.0
            .children()
            .find_map(<Parameters as rowan::ast::AstNode>::cast)
    }
    pub fn body(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for NamedFunctionDefinition {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::NAMED_FUNCTION_DEFINITION
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if NamedFunctionDefinition::can_cast(node.kind()) {
            Some(NamedFunctionDefinition(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct NamedModuleDefinition(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl NamedModuleDefinition {
    pub fn params_opt(&self) -> Option<Parameters> {
        self.0
            .children()
            .find_map(<Parameters as rowan::ast::AstNode>::cast)
    }
    pub fn body(&self) -> Option<Statement> {
        self.0
            .children()
            .find_map(<Statement as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for NamedModuleDefinition {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::NAMED_MODULE_DEFINITION
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if NamedModuleDefinition::can_cast(node.kind()) {
            Some(NamedModuleDefinition(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct ModuleInstantiation(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl ModuleInstantiation {
    pub fn args_opt(&self) -> Option<Arguments> {
        self.0
            .children()
            .find_map(<Arguments as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for ModuleInstantiation {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::MODULE_INSTANTIATION
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if ModuleInstantiation::can_cast(node.kind()) {
            Some(ModuleInstantiation(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct Expressions(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Expressions {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0
            .children()
            .filter_map(<Expr as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for Expressions {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::EXPRESSIONS
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Expressions::can_cast(node.kind()) {
            Some(Expressions(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct ListExpression(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl ListExpression {
    pub fn expressions(&self) -> Option<Expressions> {
        self.0
            .children()
            .find_map(<Expressions as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for ListExpression {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::LIST_EXPRESSION
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if ListExpression::can_cast(node.kind()) {
            Some(ListExpression(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct BinExpr(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl BinExpr {
    pub fn lhs(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
    pub fn rhs(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for BinExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::BIN_EXPR
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if BinExpr::can_cast(node.kind()) {
            Some(BinExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct UnaryExpr(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl UnaryExpr {
    pub fn expr(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for UnaryExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::UNARY_EXPR
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if UnaryExpr::can_cast(node.kind()) {
            Some(UnaryExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct TernaryExpr(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl TernaryExpr {
    pub fn condition(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
    pub fn truthy(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
    pub fn falsy(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for TernaryExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::TERNARY_EXPR
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if TernaryExpr::can_cast(node.kind()) {
            Some(TernaryExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct IndexExpr(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl IndexExpr {
    pub fn array(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
    pub fn index(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for IndexExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::INDEX_EXPR
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if IndexExpr::can_cast(node.kind()) {
            Some(IndexExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct ParenExpr(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl ParenExpr {
    pub fn expr(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for ParenExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::PAREN_EXPR
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if ParenExpr::can_cast(node.kind()) {
            Some(ParenExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct ListComprehensionExpr(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl ListComprehensionExpr {
    pub fn list_comprehension_elements(&self) -> Option<ListComprehensionElements> {
        self.0
            .children()
            .find_map(<ListComprehensionElements as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for ListComprehensionExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::LIST_COMPREHENSION_EXPR
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if ListComprehensionExpr::can_cast(node.kind()) {
            Some(ListComprehensionExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct LetClause(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl LetClause {
    pub fn assignments(&self) -> Option<AssignmentsOpt> {
        self.0
            .children()
            .find_map(<AssignmentsOpt as rowan::ast::AstNode>::cast)
    }
    pub fn list_comprehension_elements(&self) -> Option<ListComprehensionElements> {
        self.0
            .children()
            .find_map(<ListComprehensionElements as rowan::ast::AstNode>::cast)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for LetClause {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::LET_CLAUSE
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if LetClause::can_cast(node.kind()) {
            Some(LetClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct FunctionCall(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl FunctionCall {
    pub fn args_opt(&self) -> Option<Arguments> {
        self.0
            .children()
            .find_map(<Arguments as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for FunctionCall {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::FUNCTION_CALL
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if FunctionCall::can_cast(node.kind()) {
            Some(FunctionCall(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct RangeExpressionFromTo(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl RangeExpressionFromTo {
    pub fn from(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
    pub fn to(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for RangeExpressionFromTo {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::RANGE_EXPRESSION_FROM_TO
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if RangeExpressionFromTo::can_cast(node.kind()) {
            Some(RangeExpressionFromTo(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct RangeExpressionFromToStep(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl RangeExpressionFromToStep {
    pub fn from(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
    pub fn step_by(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
    pub fn to(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for RangeExpressionFromToStep {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::RANGE_EXPRESSION_FROM_TO_STEP
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if RangeExpressionFromToStep::can_cast(node.kind()) {
            Some(RangeExpressionFromToStep(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct ForClause(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl ForClause {
    pub fn assignments(&self) -> Option<Assignments> {
        self.0
            .children()
            .find_map(<Assignments as rowan::ast::AstNode>::cast)
    }
    pub fn list_comprehension_elements_or_expr(&self) -> Option<ListComprehensionElementsOrExpr> {
        self.0
            .children()
            .find_map(<ListComprehensionElementsOrExpr as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for ForClause {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::FOR_CLAUSE
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if ForClause::can_cast(node.kind()) {
            Some(ForClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct IfClause(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl IfClause {
    pub fn condition(&self) -> Option<Expr> {
        self.0
            .children()
            .find_map(<Expr as rowan::ast::AstNode>::cast)
    }
    pub fn list_comprehension_elements_or_expr(&self) -> Option<ListComprehensionElementsOrExpr> {
        self.0
            .children()
            .find_map(<ListComprehensionElementsOrExpr as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for IfClause {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::IF_CLAUSE
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if IfClause::can_cast(node.kind()) {
            Some(IfClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct AssignmentsOpt(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl AssignmentsOpt {
    pub fn assignments(&self) -> Option<Assignments> {
        self.0
            .children()
            .find_map(<Assignments as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for AssignmentsOpt {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::ASSIGNMENTS_OPT
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if AssignmentsOpt::can_cast(node.kind()) {
            Some(AssignmentsOpt(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct Assignments(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Assignments {
    pub fn assignments(&self) -> impl Iterator<Item = Assignment> {
        self.0
            .children()
            .filter_map(<Assignment as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for Assignments {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::ASSIGNMENTS
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Assignments::can_cast(node.kind()) {
            Some(Assignments(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct Parameters(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Parameters {
    pub fn parameters(&self) -> impl Iterator<Item = Parameter> {
        self.0
            .children()
            .filter_map(<Parameter as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for Parameters {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::PARAMETERS
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Parameters::can_cast(node.kind()) {
            Some(Parameters(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct Arguments(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Arguments {
    pub fn arguments(&self) -> impl Iterator<Item = Argument> {
        self.0
            .children()
            .filter_map(<Argument as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for Arguments {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::ARGUMENTS
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Arguments::can_cast(node.kind()) {
            Some(Arguments(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct Children(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Children {
    pub fn childs(&self) -> impl Iterator<Item = Child> {
        self.0
            .children()
            .filter_map(<Child as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for Children {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::CHILDREN
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Children::can_cast(node.kind()) {
            Some(Children(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub struct BracedChildren(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl BracedChildren {
    pub fn children(&self) -> Option<Children> {
        self.0
            .children()
            .find_map(<Children as rowan::ast::AstNode>::cast)
    }
}
impl rowan::ast::AstNode for BracedChildren {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::BRACED_CHILDREN
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if BracedChildren::can_cast(node.kind()) {
            Some(BracedChildren(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
pub enum Statement {
    Include(Include),
    Use(Use),
    Assignment(Assignment),
    NamedFunctionDefinition(NamedFunctionDefinition),
    NamedModuleDefinition(NamedModuleDefinition),
    ModuleInstantiation(ModuleInstantiation),
}
impl Statement {}
impl rowan::ast::AstNode for Statement {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        <Include as rowan::ast::AstNode>::can_cast(kind)
            || <Use as rowan::ast::AstNode>::can_cast(kind)
            || <Assignment as rowan::ast::AstNode>::can_cast(kind)
            || <NamedFunctionDefinition as rowan::ast::AstNode>::can_cast(kind)
            || <NamedModuleDefinition as rowan::ast::AstNode>::can_cast(kind)
            || <ModuleInstantiation as rowan::ast::AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if let Some(node) = <Include as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <Use as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <Assignment as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <NamedFunctionDefinition as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <NamedModuleDefinition as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <ModuleInstantiation as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        None
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        match self {
            Statement::Include(node) => node.syntax(),
            Statement::Use(node) => node.syntax(),
            Statement::Assignment(node) => node.syntax(),
            Statement::NamedFunctionDefinition(node) => node.syntax(),
            Statement::NamedModuleDefinition(node) => node.syntax(),
            Statement::ModuleInstantiation(node) => node.syntax(),
        }
    }
}
impl From<Include> for Statement {
    fn from(value: Include) -> Statement {
        Statement::Include(value)
    }
}
impl From<Use> for Statement {
    fn from(value: Use) -> Statement {
        Statement::Use(value)
    }
}
impl From<Assignment> for Statement {
    fn from(value: Assignment) -> Statement {
        Statement::Assignment(value)
    }
}
impl From<NamedFunctionDefinition> for Statement {
    fn from(value: NamedFunctionDefinition) -> Statement {
        Statement::NamedFunctionDefinition(value)
    }
}
impl From<NamedModuleDefinition> for Statement {
    fn from(value: NamedModuleDefinition) -> Statement {
        Statement::NamedModuleDefinition(value)
    }
}
impl From<ModuleInstantiation> for Statement {
    fn from(value: ModuleInstantiation) -> Statement {
        Statement::ModuleInstantiation(value)
    }
}
pub enum Expr {
    RangeExpression(RangeExpression),
    ListExpression(ListExpression),
    BinExpr(BinExpr),
    UnaryExpr(UnaryExpr),
    TernaryExpr(TernaryExpr),
    IndexExpr(IndexExpr),
    ParenExpr(ParenExpr),
    ListComprehensionExpr(ListComprehensionExpr),
    LetClause(LetClause),
    FunctionCall(FunctionCall),
}
impl Expr {}
impl rowan::ast::AstNode for Expr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        <RangeExpression as rowan::ast::AstNode>::can_cast(kind)
            || <ListExpression as rowan::ast::AstNode>::can_cast(kind)
            || <BinExpr as rowan::ast::AstNode>::can_cast(kind)
            || <UnaryExpr as rowan::ast::AstNode>::can_cast(kind)
            || <TernaryExpr as rowan::ast::AstNode>::can_cast(kind)
            || <IndexExpr as rowan::ast::AstNode>::can_cast(kind)
            || <ParenExpr as rowan::ast::AstNode>::can_cast(kind)
            || <ListComprehensionExpr as rowan::ast::AstNode>::can_cast(kind)
            || <LetClause as rowan::ast::AstNode>::can_cast(kind)
            || <FunctionCall as rowan::ast::AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if let Some(node) = <RangeExpression as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <ListExpression as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <BinExpr as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <UnaryExpr as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <TernaryExpr as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <IndexExpr as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <ParenExpr as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <ListComprehensionExpr as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <LetClause as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <FunctionCall as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        None
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        match self {
            Expr::RangeExpression(node) => node.syntax(),
            Expr::ListExpression(node) => node.syntax(),
            Expr::BinExpr(node) => node.syntax(),
            Expr::UnaryExpr(node) => node.syntax(),
            Expr::TernaryExpr(node) => node.syntax(),
            Expr::IndexExpr(node) => node.syntax(),
            Expr::ParenExpr(node) => node.syntax(),
            Expr::ListComprehensionExpr(node) => node.syntax(),
            Expr::LetClause(node) => node.syntax(),
            Expr::FunctionCall(node) => node.syntax(),
        }
    }
}
impl From<RangeExpression> for Expr {
    fn from(value: RangeExpression) -> Expr {
        Expr::RangeExpression(value)
    }
}
impl From<ListExpression> for Expr {
    fn from(value: ListExpression) -> Expr {
        Expr::ListExpression(value)
    }
}
impl From<BinExpr> for Expr {
    fn from(value: BinExpr) -> Expr {
        Expr::BinExpr(value)
    }
}
impl From<UnaryExpr> for Expr {
    fn from(value: UnaryExpr) -> Expr {
        Expr::UnaryExpr(value)
    }
}
impl From<TernaryExpr> for Expr {
    fn from(value: TernaryExpr) -> Expr {
        Expr::TernaryExpr(value)
    }
}
impl From<IndexExpr> for Expr {
    fn from(value: IndexExpr) -> Expr {
        Expr::IndexExpr(value)
    }
}
impl From<ParenExpr> for Expr {
    fn from(value: ParenExpr) -> Expr {
        Expr::ParenExpr(value)
    }
}
impl From<ListComprehensionExpr> for Expr {
    fn from(value: ListComprehensionExpr) -> Expr {
        Expr::ListComprehensionExpr(value)
    }
}
impl From<LetClause> for Expr {
    fn from(value: LetClause) -> Expr {
        Expr::LetClause(value)
    }
}
impl From<FunctionCall> for Expr {
    fn from(value: FunctionCall) -> Expr {
        Expr::FunctionCall(value)
    }
}
pub enum RangeExpression {
    RangeExpressionFromTo(RangeExpressionFromTo),
    RangeExpressionFromToStep(RangeExpressionFromToStep),
}
impl RangeExpression {}
impl rowan::ast::AstNode for RangeExpression {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        <RangeExpressionFromTo as rowan::ast::AstNode>::can_cast(kind)
            || <RangeExpressionFromToStep as rowan::ast::AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if let Some(node) = <RangeExpressionFromTo as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <RangeExpressionFromToStep as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        None
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        match self {
            RangeExpression::RangeExpressionFromTo(node) => node.syntax(),
            RangeExpression::RangeExpressionFromToStep(node) => node.syntax(),
        }
    }
}
impl From<RangeExpressionFromTo> for RangeExpression {
    fn from(value: RangeExpressionFromTo) -> RangeExpression {
        RangeExpression::RangeExpressionFromTo(value)
    }
}
impl From<RangeExpressionFromToStep> for RangeExpression {
    fn from(value: RangeExpressionFromToStep) -> RangeExpression {
        RangeExpression::RangeExpressionFromToStep(value)
    }
}
pub enum ListComprehensionElements {
    LetClause(LetClause),
    ForClause(ForClause),
    IfClause(IfClause),
}
impl ListComprehensionElements {}
impl rowan::ast::AstNode for ListComprehensionElements {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        <LetClause as rowan::ast::AstNode>::can_cast(kind)
            || <ForClause as rowan::ast::AstNode>::can_cast(kind)
            || <IfClause as rowan::ast::AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if let Some(node) = <LetClause as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <ForClause as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <IfClause as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        None
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        match self {
            ListComprehensionElements::LetClause(node) => node.syntax(),
            ListComprehensionElements::ForClause(node) => node.syntax(),
            ListComprehensionElements::IfClause(node) => node.syntax(),
        }
    }
}
impl From<LetClause> for ListComprehensionElements {
    fn from(value: LetClause) -> ListComprehensionElements {
        ListComprehensionElements::LetClause(value)
    }
}
impl From<ForClause> for ListComprehensionElements {
    fn from(value: ForClause) -> ListComprehensionElements {
        ListComprehensionElements::ForClause(value)
    }
}
impl From<IfClause> for ListComprehensionElements {
    fn from(value: IfClause) -> ListComprehensionElements {
        ListComprehensionElements::IfClause(value)
    }
}
pub enum ListComprehensionElementsOrExpr {
    ListComprehensionElements(ListComprehensionElements),
    Expr(Expr),
}
impl ListComprehensionElementsOrExpr {}
impl rowan::ast::AstNode for ListComprehensionElementsOrExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        <ListComprehensionElements as rowan::ast::AstNode>::can_cast(kind)
            || <Expr as rowan::ast::AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if let Some(node) = <ListComprehensionElements as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <Expr as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        None
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        match self {
            ListComprehensionElementsOrExpr::ListComprehensionElements(node) => node.syntax(),
            ListComprehensionElementsOrExpr::Expr(node) => node.syntax(),
        }
    }
}
impl From<ListComprehensionElements> for ListComprehensionElementsOrExpr {
    fn from(value: ListComprehensionElements) -> ListComprehensionElementsOrExpr {
        ListComprehensionElementsOrExpr::ListComprehensionElements(value)
    }
}
impl From<Expr> for ListComprehensionElementsOrExpr {
    fn from(value: Expr) -> ListComprehensionElementsOrExpr {
        ListComprehensionElementsOrExpr::Expr(value)
    }
}
pub enum Child {
    BracedChildren(BracedChildren),
    ModuleInstantiation(ModuleInstantiation),
}
impl Child {}
impl rowan::ast::AstNode for Child {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        <BracedChildren as rowan::ast::AstNode>::can_cast(kind)
            || <ModuleInstantiation as rowan::ast::AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if let Some(node) = <BracedChildren as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <ModuleInstantiation as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        None
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        match self {
            Child::BracedChildren(node) => node.syntax(),
            Child::ModuleInstantiation(node) => node.syntax(),
        }
    }
}
impl From<BracedChildren> for Child {
    fn from(value: BracedChildren) -> Child {
        Child::BracedChildren(value)
    }
}
impl From<ModuleInstantiation> for Child {
    fn from(value: ModuleInstantiation) -> Child {
        Child::ModuleInstantiation(value)
    }
}
pub enum Parameter {
    Assignment(Assignment),
}
impl Parameter {}
impl rowan::ast::AstNode for Parameter {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        <Assignment as rowan::ast::AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if let Some(node) = <Assignment as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        None
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        match self {
            Parameter::Assignment(node) => node.syntax(),
        }
    }
}
impl From<Assignment> for Parameter {
    fn from(value: Assignment) -> Parameter {
        Parameter::Assignment(value)
    }
}
pub enum Argument {
    Expr(Expr),
    Assignment(Assignment),
}
impl Argument {}
impl rowan::ast::AstNode for Argument {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        <Expr as rowan::ast::AstNode>::can_cast(kind)
            || <Assignment as rowan::ast::AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if let Some(node) = <Expr as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <Assignment as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        None
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        match self {
            Argument::Expr(node) => node.syntax(),
            Argument::Assignment(node) => node.syntax(),
        }
    }
}
impl From<Expr> for Argument {
    fn from(value: Expr) -> Argument {
        Argument::Expr(value)
    }
}
impl From<Assignment> for Argument {
    fn from(value: Assignment) -> Argument {
        Argument::Assignment(value)
    }
}
