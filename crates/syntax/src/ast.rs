// Generated by `scad_codegen::syntax::tests`. DO NOT EDIT!

#![doc = r" Automatically generated, strongly-typed [`AstNode`]s."]
use crate::{SyntaxKind, SyntaxNode, SyntaxToken};
use rowan::{ast::AstNode, TextRange};
#[doc = "A strongly typed wrapper around a [`PACKAGE`][SyntaxKind::PACKAGE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Package = Statement*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Package(SyntaxNode);
impl AstNode for Package {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::PACKAGE
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if Package::can_cast(node.kind()) {
            Some(Package(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl Package {
    pub fn statements(&self) -> impl Iterator<Item = Statement> {
        self.0.children().filter_map(Statement::cast)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed `Statement` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Statement = Include | Use | AssignmentStatement | NamedFunctionDefinition | NamedModuleDefinition | ModuleInstantiation | IfStatement | ForStatement;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Statement {
    Include(Include),
    Use(Use),
    AssignmentStatement(AssignmentStatement),
    NamedFunctionDefinition(NamedFunctionDefinition),
    NamedModuleDefinition(NamedModuleDefinition),
    ModuleInstantiation(ModuleInstantiation),
    IfStatement(IfStatement),
    ForStatement(ForStatement),
}
impl AstNode for Statement {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        Include::can_cast(kind)
            || Use::can_cast(kind)
            || AssignmentStatement::can_cast(kind)
            || NamedFunctionDefinition::can_cast(kind)
            || NamedModuleDefinition::can_cast(kind)
            || ModuleInstantiation::can_cast(kind)
            || IfStatement::can_cast(kind)
            || ForStatement::can_cast(kind)
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = Include::cast(node.clone()) {
            return Some(Statement::Include(variant));
        }
        if let Some(variant) = Use::cast(node.clone()) {
            return Some(Statement::Use(variant));
        }
        if let Some(variant) = AssignmentStatement::cast(node.clone()) {
            return Some(Statement::AssignmentStatement(variant));
        }
        if let Some(variant) = NamedFunctionDefinition::cast(node.clone()) {
            return Some(Statement::NamedFunctionDefinition(variant));
        }
        if let Some(variant) = NamedModuleDefinition::cast(node.clone()) {
            return Some(Statement::NamedModuleDefinition(variant));
        }
        if let Some(variant) = ModuleInstantiation::cast(node.clone()) {
            return Some(Statement::ModuleInstantiation(variant));
        }
        if let Some(variant) = IfStatement::cast(node.clone()) {
            return Some(Statement::IfStatement(variant));
        }
        if let Some(variant) = ForStatement::cast(node.clone()) {
            return Some(Statement::ForStatement(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Statement::Include(node) => node.syntax(),
            Statement::Use(node) => node.syntax(),
            Statement::AssignmentStatement(node) => node.syntax(),
            Statement::NamedFunctionDefinition(node) => node.syntax(),
            Statement::NamedModuleDefinition(node) => node.syntax(),
            Statement::ModuleInstantiation(node) => node.syntax(),
            Statement::IfStatement(node) => node.syntax(),
            Statement::ForStatement(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`INCLUDE`][SyntaxKind::INCLUDE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Include = 'include' 'file';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Include(SyntaxNode);
impl AstNode for Include {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::INCLUDE
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if Include::can_cast(node.kind()) {
            Some(Include(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl Include {
    pub fn include_kw_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::INCLUDE_KW)
    }
    pub fn file_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::FILE)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`USE`][SyntaxKind::USE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Use = 'use' 'file';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Use(SyntaxNode);
impl AstNode for Use {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::USE
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if Use::can_cast(node.kind()) {
            Some(Use(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl Use {
    pub fn use_kw_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::USE_KW)
    }
    pub fn file_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::FILE)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`ASSIGNMENT_STATEMENT`][SyntaxKind::ASSIGNMENT_STATEMENT] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "AssignmentStatement = Assignment ';';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignmentStatement(SyntaxNode);
impl AstNode for AssignmentStatement {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ASSIGNMENT_STATEMENT
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if AssignmentStatement::can_cast(node.kind()) {
            Some(AssignmentStatement(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl AssignmentStatement {
    pub fn assignment(&self) -> Option<Assignment> {
        self.0.children().find_map(Assignment::cast)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::SEMICOLON)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`NAMED_FUNCTION_DEFINITION`][SyntaxKind::NAMED_FUNCTION_DEFINITION] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "NamedFunctionDefinition = 'function' 'ident' '(' params:Parameters? ')' '=' body:Expr ';';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFunctionDefinition(SyntaxNode);
impl AstNode for NamedFunctionDefinition {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::NAMED_FUNCTION_DEFINITION
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if NamedFunctionDefinition::can_cast(node.kind()) {
            Some(NamedFunctionDefinition(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl NamedFunctionDefinition {
    pub fn function_kw_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::FUNCTION_KW)
    }
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IDENT)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn parameters_opt(&self) -> Option<Parameters> {
        self.0.children().find_map(Parameters::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn equals_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::EQUALS)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::SEMICOLON)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`NAMED_MODULE_DEFINITION`][SyntaxKind::NAMED_MODULE_DEFINITION] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "NamedModuleDefinition = 'module' 'ident' '(' params:Parameters? ')' '{' body:Statement* '}';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedModuleDefinition(SyntaxNode);
impl AstNode for NamedModuleDefinition {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::NAMED_MODULE_DEFINITION
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if NamedModuleDefinition::can_cast(node.kind()) {
            Some(NamedModuleDefinition(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl NamedModuleDefinition {
    pub fn module_kw_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::MODULE_KW)
    }
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IDENT)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn parameters_opt(&self) -> Option<Parameters> {
        self.0.children().find_map(Parameters::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_CURLY)
    }
    pub fn statements(&self) -> impl Iterator<Item = Statement> {
        self.0.children().filter_map(Statement::cast)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_CURLY)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`MODULE_INSTANTIATION`][SyntaxKind::MODULE_INSTANTIATION] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ModuleInstantiation = 'ident' '(' args:Arguments? ')' Child;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuleInstantiation(SyntaxNode);
impl AstNode for ModuleInstantiation {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::MODULE_INSTANTIATION
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if ModuleInstantiation::can_cast(node.kind()) {
            Some(ModuleInstantiation(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl ModuleInstantiation {
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IDENT)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn arguments_opt(&self) -> Option<Arguments> {
        self.0.children().find_map(Arguments::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn child(&self) -> Option<Child> {
        self.0.children().find_map(Child::cast)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`IF_STATEMENT`][SyntaxKind::IF_STATEMENT] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "IfStatement = 'if' '(' Expr ')' Actions ('else' Actions)?;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfStatement(SyntaxNode);
impl AstNode for IfStatement {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::IF_STATEMENT
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if IfStatement::can_cast(node.kind()) {
            Some(IfStatement(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl IfStatement {
    pub fn if_kw_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IF_KW)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn actions(&self) -> impl Iterator<Item = Actions> {
        self.0.children().filter_map(Actions::cast)
    }
    pub fn else_kw_token_opt(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::ELSE_KW)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`FOR_STATEMENT`][SyntaxKind::FOR_STATEMENT] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ForStatement = 'for' '(' Assignments ')' Actions;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForStatement(SyntaxNode);
impl AstNode for ForStatement {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::FOR_STATEMENT
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if ForStatement::can_cast(node.kind()) {
            Some(ForStatement(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl ForStatement {
    pub fn for_kw_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::FOR_KW)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn assignments(&self) -> Option<Assignments> {
        self.0.children().find_map(Assignments::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn actions(&self) -> Option<Actions> {
        self.0.children().find_map(Actions::cast)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed `Expr` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Expr = Atom | ListExpr | RangeExpr | UnaryExpr | TernaryExpr | ParenExpr | ListComprehensionExpr | BinExpr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    Atom(Atom),
    ListExpr(ListExpr),
    RangeExpr(RangeExpr),
    UnaryExpr(UnaryExpr),
    TernaryExpr(TernaryExpr),
    ParenExpr(ParenExpr),
    ListComprehensionExpr(ListComprehensionExpr),
    BinExpr(BinExpr),
}
impl AstNode for Expr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        Atom::can_cast(kind)
            || ListExpr::can_cast(kind)
            || RangeExpr::can_cast(kind)
            || UnaryExpr::can_cast(kind)
            || TernaryExpr::can_cast(kind)
            || ParenExpr::can_cast(kind)
            || ListComprehensionExpr::can_cast(kind)
            || BinExpr::can_cast(kind)
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = Atom::cast(node.clone()) {
            return Some(Expr::Atom(variant));
        }
        if let Some(variant) = ListExpr::cast(node.clone()) {
            return Some(Expr::ListExpr(variant));
        }
        if let Some(variant) = RangeExpr::cast(node.clone()) {
            return Some(Expr::RangeExpr(variant));
        }
        if let Some(variant) = UnaryExpr::cast(node.clone()) {
            return Some(Expr::UnaryExpr(variant));
        }
        if let Some(variant) = TernaryExpr::cast(node.clone()) {
            return Some(Expr::TernaryExpr(variant));
        }
        if let Some(variant) = ParenExpr::cast(node.clone()) {
            return Some(Expr::ParenExpr(variant));
        }
        if let Some(variant) = ListComprehensionExpr::cast(node.clone()) {
            return Some(Expr::ListComprehensionExpr(variant));
        }
        if let Some(variant) = BinExpr::cast(node.clone()) {
            return Some(Expr::BinExpr(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expr::Atom(node) => node.syntax(),
            Expr::ListExpr(node) => node.syntax(),
            Expr::RangeExpr(node) => node.syntax(),
            Expr::UnaryExpr(node) => node.syntax(),
            Expr::TernaryExpr(node) => node.syntax(),
            Expr::ParenExpr(node) => node.syntax(),
            Expr::ListComprehensionExpr(node) => node.syntax(),
            Expr::BinExpr(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed `Actions` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Actions = Action | BracedActions;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Actions {
    Action(Action),
    BracedActions(BracedActions),
}
impl AstNode for Actions {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        Action::can_cast(kind) || BracedActions::can_cast(kind)
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = Action::cast(node.clone()) {
            return Some(Actions::Action(variant));
        }
        if let Some(variant) = BracedActions::cast(node.clone()) {
            return Some(Actions::BracedActions(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Actions::Action(node) => node.syntax(),
            Actions::BracedActions(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`ASSIGNMENTS`][SyntaxKind::ASSIGNMENTS] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Assignments = Assignment (',' Assignment)*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Assignments(SyntaxNode);
impl AstNode for Assignments {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ASSIGNMENTS
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if Assignments::can_cast(node.kind()) {
            Some(Assignments(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl Assignments {
    pub fn assignments(&self) -> impl Iterator<Item = Assignment> {
        self.0.children().filter_map(Assignment::cast)
    }
    pub fn comma_tokens(&self) -> impl Iterator<Item = SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::COMMA)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed `Action` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Action = AssignmentStatement | ModuleInstantiation | IfStatement | ForStatement;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Action {
    AssignmentStatement(AssignmentStatement),
    ModuleInstantiation(ModuleInstantiation),
    IfStatement(IfStatement),
    ForStatement(ForStatement),
}
impl AstNode for Action {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        AssignmentStatement::can_cast(kind)
            || ModuleInstantiation::can_cast(kind)
            || IfStatement::can_cast(kind)
            || ForStatement::can_cast(kind)
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = AssignmentStatement::cast(node.clone()) {
            return Some(Action::AssignmentStatement(variant));
        }
        if let Some(variant) = ModuleInstantiation::cast(node.clone()) {
            return Some(Action::ModuleInstantiation(variant));
        }
        if let Some(variant) = IfStatement::cast(node.clone()) {
            return Some(Action::IfStatement(variant));
        }
        if let Some(variant) = ForStatement::cast(node.clone()) {
            return Some(Action::ForStatement(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Action::AssignmentStatement(node) => node.syntax(),
            Action::ModuleInstantiation(node) => node.syntax(),
            Action::IfStatement(node) => node.syntax(),
            Action::ForStatement(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`BRACED_ACTIONS`][SyntaxKind::BRACED_ACTIONS] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "BracedActions = '{' Action* '}';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BracedActions(SyntaxNode);
impl AstNode for BracedActions {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::BRACED_ACTIONS
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if BracedActions::can_cast(node.kind()) {
            Some(BracedActions(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl BracedActions {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_CURLY)
    }
    pub fn actions(&self) -> impl Iterator<Item = Action> {
        self.0.children().filter_map(Action::cast)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_CURLY)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`ASSIGNMENT`][SyntaxKind::ASSIGNMENT] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Assignment = name:'ident' '=' value:Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Assignment(SyntaxNode);
impl AstNode for Assignment {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ASSIGNMENT
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if Assignment::can_cast(node.kind()) {
            Some(Assignment(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl Assignment {
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IDENT)
    }
    pub fn equals_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::EQUALS)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed `Atom` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Atom = LiteralExpr | LookupExpr | IndexExpr | FunctionCall;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Atom {
    LiteralExpr(LiteralExpr),
    LookupExpr(LookupExpr),
    IndexExpr(IndexExpr),
    FunctionCall(FunctionCall),
}
impl AstNode for Atom {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        LiteralExpr::can_cast(kind)
            || LookupExpr::can_cast(kind)
            || IndexExpr::can_cast(kind)
            || FunctionCall::can_cast(kind)
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = LiteralExpr::cast(node.clone()) {
            return Some(Atom::LiteralExpr(variant));
        }
        if let Some(variant) = LookupExpr::cast(node.clone()) {
            return Some(Atom::LookupExpr(variant));
        }
        if let Some(variant) = IndexExpr::cast(node.clone()) {
            return Some(Atom::IndexExpr(variant));
        }
        if let Some(variant) = FunctionCall::cast(node.clone()) {
            return Some(Atom::FunctionCall(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Atom::LiteralExpr(node) => node.syntax(),
            Atom::LookupExpr(node) => node.syntax(),
            Atom::IndexExpr(node) => node.syntax(),
            Atom::FunctionCall(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`LIST_EXPR`][SyntaxKind::LIST_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ListExpr = '[' Expr (',' Expr)* ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListExpr(SyntaxNode);
impl AstNode for ListExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::LIST_EXPR
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if ListExpr::can_cast(node.kind()) {
            Some(ListExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl ListExpr {
    pub fn l_bracket_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_BRACKET)
    }
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn comma_tokens(&self) -> impl Iterator<Item = SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::COMMA)
    }
    pub fn r_bracket_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_BRACKET)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed `RangeExpr` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "RangeExpr = RangeExprFromTo | RangeExprFromToStep;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RangeExpr {
    RangeExprFromTo(RangeExprFromTo),
    RangeExprFromToStep(RangeExprFromToStep),
}
impl AstNode for RangeExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        RangeExprFromTo::can_cast(kind) || RangeExprFromToStep::can_cast(kind)
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = RangeExprFromTo::cast(node.clone()) {
            return Some(RangeExpr::RangeExprFromTo(variant));
        }
        if let Some(variant) = RangeExprFromToStep::cast(node.clone()) {
            return Some(RangeExpr::RangeExprFromToStep(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            RangeExpr::RangeExprFromTo(node) => node.syntax(),
            RangeExpr::RangeExprFromToStep(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`UNARY_EXPR`][SyntaxKind::UNARY_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "UnaryExpr = ('!' | '+' | '-') Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnaryExpr(SyntaxNode);
impl AstNode for UnaryExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::UNARY_EXPR
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if UnaryExpr::can_cast(node.kind()) {
            Some(UnaryExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl UnaryExpr {
    pub fn bang_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::BANG)
    }
    pub fn plus_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::PLUS)
    }
    pub fn minus_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::MINUS)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`TERNARY_EXPR`][SyntaxKind::TERNARY_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "TernaryExpr = Expr '?' Expr ':' Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TernaryExpr(SyntaxNode);
impl AstNode for TernaryExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::TERNARY_EXPR
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if TernaryExpr::can_cast(node.kind()) {
            Some(TernaryExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl TernaryExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn question_mark_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::QUESTION_MARK)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::COLON)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`PAREN_EXPR`][SyntaxKind::PAREN_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ParenExpr = '(' Expr ')';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr(SyntaxNode);
impl AstNode for ParenExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::PAREN_EXPR
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if ParenExpr::can_cast(node.kind()) {
            Some(ParenExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl ParenExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`LIST_COMPREHENSION_EXPR`][SyntaxKind::LIST_COMPREHENSION_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ListComprehensionExpr = '[' ForClause ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListComprehensionExpr(SyntaxNode);
impl AstNode for ListComprehensionExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::LIST_COMPREHENSION_EXPR
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if ListComprehensionExpr::can_cast(node.kind()) {
            Some(ListComprehensionExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl ListComprehensionExpr {
    pub fn l_bracket_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_BRACKET)
    }
    pub fn for_clause(&self) -> Option<ForClause> {
        self.0.children().find_map(ForClause::cast)
    }
    pub fn r_bracket_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_BRACKET)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`BIN_EXPR`][SyntaxKind::BIN_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "BinExpr = Expr (BinOp Expr)*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr(SyntaxNode);
impl AstNode for BinExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::BIN_EXPR
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if BinExpr::can_cast(node.kind()) {
            Some(BinExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl BinExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn bin_ops(&self) -> impl Iterator<Item = BinOp> {
        self.0.children().filter_map(BinOp::cast)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed `LiteralExpr` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "LiteralExpr = 'true' | 'false' | 'undef' | 'integer' | 'float' | 'string';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum LiteralExpr {
    TrueKw(TrueKwToken),
    FalseKw(FalseKwToken),
    UndefKw(UndefKwToken),
    Integer(IntegerToken),
    Float(FloatToken),
    String(StringToken),
}
impl AstNode for LiteralExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::TRUE_KW
            || kind == SyntaxKind::FALSE_KW
            || kind == SyntaxKind::UNDEF_KW
            || kind == SyntaxKind::INTEGER
            || kind == SyntaxKind::FLOAT
            || kind == SyntaxKind::STRING
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(token) = TrueKwToken::cast(node.clone()) {
            return Some(LiteralExpr::TrueKw(token));
        }
        if let Some(token) = FalseKwToken::cast(node.clone()) {
            return Some(LiteralExpr::FalseKw(token));
        }
        if let Some(token) = UndefKwToken::cast(node.clone()) {
            return Some(LiteralExpr::UndefKw(token));
        }
        if let Some(token) = IntegerToken::cast(node.clone()) {
            return Some(LiteralExpr::Integer(token));
        }
        if let Some(token) = FloatToken::cast(node.clone()) {
            return Some(LiteralExpr::Float(token));
        }
        if let Some(token) = StringToken::cast(node.clone()) {
            return Some(LiteralExpr::String(token));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            LiteralExpr::TrueKw(node) => node.syntax(),
            LiteralExpr::FalseKw(node) => node.syntax(),
            LiteralExpr::UndefKw(node) => node.syntax(),
            LiteralExpr::Integer(node) => node.syntax(),
            LiteralExpr::Float(node) => node.syntax(),
            LiteralExpr::String(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`LOOKUP_EXPR`][SyntaxKind::LOOKUP_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "LookupExpr = 'ident' ('.' 'ident')*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LookupExpr(SyntaxNode);
impl AstNode for LookupExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::LOOKUP_EXPR
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if LookupExpr::can_cast(node.kind()) {
            Some(LookupExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl LookupExpr {
    pub fn ident_tokens(&self) -> impl Iterator<Item = SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::IDENT)
    }
    pub fn dot_tokens(&self) -> impl Iterator<Item = SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::DOT)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`INDEX_EXPR`][SyntaxKind::INDEX_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "IndexExpr = Expr '[' Expr ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr(SyntaxNode);
impl AstNode for IndexExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::INDEX_EXPR
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if IndexExpr::can_cast(node.kind()) {
            Some(IndexExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl IndexExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn l_bracket_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_BRACKET)
    }
    pub fn r_bracket_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_BRACKET)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`FUNCTION_CALL`][SyntaxKind::FUNCTION_CALL] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "FunctionCall = 'ident' '(' args:Arguments? ')';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionCall(SyntaxNode);
impl AstNode for FunctionCall {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::FUNCTION_CALL
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if FunctionCall::can_cast(node.kind()) {
            Some(FunctionCall(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl FunctionCall {
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IDENT)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn arguments_opt(&self) -> Option<Arguments> {
        self.0.children().find_map(Arguments::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`FOR_CLAUSE`][SyntaxKind::FOR_CLAUSE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ForClause = 'for' '(' assignments:Assignments ')' ListComprehensionElementOrExpr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForClause(SyntaxNode);
impl AstNode for ForClause {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::FOR_CLAUSE
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if ForClause::can_cast(node.kind()) {
            Some(ForClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl ForClause {
    pub fn for_kw_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::FOR_KW)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn assignments(&self) -> Option<Assignments> {
        self.0.children().find_map(Assignments::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn list_comprehension_element_or_expr(&self) -> Option<ListComprehensionElementOrExpr> {
        self.0
            .children()
            .find_map(ListComprehensionElementOrExpr::cast)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed `BinOp` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "BinOp = '+' | '-' | '*' | '/' | '%' | '^' | '>=' | '>' | '==' | '!=' | '<=' | '<' | '&&' | '||';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum BinOp {
    Plus(PlusToken),
    Minus(MinusToken),
    Star(StarToken),
    Slash(SlashToken),
    Percent(PercentToken),
    Caret(CaretToken),
    GreaterThanEquals(GreaterThanEqualsToken),
    GreaterThan(GreaterThanToken),
    DoubleEquals(DoubleEqualsToken),
    NotEqual(NotEqualToken),
    LessThanEquals(LessThanEqualsToken),
    LessThan(LessThanToken),
    And(AndToken),
    Or(OrToken),
}
impl AstNode for BinOp {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::PLUS
            || kind == SyntaxKind::MINUS
            || kind == SyntaxKind::STAR
            || kind == SyntaxKind::SLASH
            || kind == SyntaxKind::PERCENT
            || kind == SyntaxKind::CARET
            || kind == SyntaxKind::GREATER_THAN_EQUALS
            || kind == SyntaxKind::GREATER_THAN
            || kind == SyntaxKind::DOUBLE_EQUALS
            || kind == SyntaxKind::NOT_EQUAL
            || kind == SyntaxKind::LESS_THAN_EQUALS
            || kind == SyntaxKind::LESS_THAN
            || kind == SyntaxKind::AND
            || kind == SyntaxKind::OR
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(token) = PlusToken::cast(node.clone()) {
            return Some(BinOp::Plus(token));
        }
        if let Some(token) = MinusToken::cast(node.clone()) {
            return Some(BinOp::Minus(token));
        }
        if let Some(token) = StarToken::cast(node.clone()) {
            return Some(BinOp::Star(token));
        }
        if let Some(token) = SlashToken::cast(node.clone()) {
            return Some(BinOp::Slash(token));
        }
        if let Some(token) = PercentToken::cast(node.clone()) {
            return Some(BinOp::Percent(token));
        }
        if let Some(token) = CaretToken::cast(node.clone()) {
            return Some(BinOp::Caret(token));
        }
        if let Some(token) = GreaterThanEqualsToken::cast(node.clone()) {
            return Some(BinOp::GreaterThanEquals(token));
        }
        if let Some(token) = GreaterThanToken::cast(node.clone()) {
            return Some(BinOp::GreaterThan(token));
        }
        if let Some(token) = DoubleEqualsToken::cast(node.clone()) {
            return Some(BinOp::DoubleEquals(token));
        }
        if let Some(token) = NotEqualToken::cast(node.clone()) {
            return Some(BinOp::NotEqual(token));
        }
        if let Some(token) = LessThanEqualsToken::cast(node.clone()) {
            return Some(BinOp::LessThanEquals(token));
        }
        if let Some(token) = LessThanToken::cast(node.clone()) {
            return Some(BinOp::LessThan(token));
        }
        if let Some(token) = AndToken::cast(node.clone()) {
            return Some(BinOp::And(token));
        }
        if let Some(token) = OrToken::cast(node.clone()) {
            return Some(BinOp::Or(token));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            BinOp::Plus(node) => node.syntax(),
            BinOp::Minus(node) => node.syntax(),
            BinOp::Star(node) => node.syntax(),
            BinOp::Slash(node) => node.syntax(),
            BinOp::Percent(node) => node.syntax(),
            BinOp::Caret(node) => node.syntax(),
            BinOp::GreaterThanEquals(node) => node.syntax(),
            BinOp::GreaterThan(node) => node.syntax(),
            BinOp::DoubleEquals(node) => node.syntax(),
            BinOp::NotEqual(node) => node.syntax(),
            BinOp::LessThanEquals(node) => node.syntax(),
            BinOp::LessThan(node) => node.syntax(),
            BinOp::And(node) => node.syntax(),
            BinOp::Or(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`RANGE_EXPR_FROM_TO`][SyntaxKind::RANGE_EXPR_FROM_TO] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "RangeExprFromTo = '[' Expr ':' Expr ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExprFromTo(SyntaxNode);
impl AstNode for RangeExprFromTo {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::RANGE_EXPR_FROM_TO
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if RangeExprFromTo::can_cast(node.kind()) {
            Some(RangeExprFromTo(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl RangeExprFromTo {
    pub fn l_bracket_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_BRACKET)
    }
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::COLON)
    }
    pub fn r_bracket_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_BRACKET)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`RANGE_EXPR_FROM_TO_STEP`][SyntaxKind::RANGE_EXPR_FROM_TO_STEP] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "RangeExprFromToStep = '[' Expr ':' Expr ':' Expr ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExprFromToStep(SyntaxNode);
impl AstNode for RangeExprFromToStep {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::RANGE_EXPR_FROM_TO_STEP
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if RangeExprFromToStep::can_cast(node.kind()) {
            Some(RangeExprFromToStep(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl RangeExprFromToStep {
    pub fn l_bracket_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_BRACKET)
    }
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn colon_tokens(&self) -> impl Iterator<Item = SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::COLON)
    }
    pub fn r_bracket_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_BRACKET)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed `ListComprehensionElement` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ListComprehensionElement = LetClause | ForClause | IfClause;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ListComprehensionElement {
    LetClause(LetClause),
    ForClause(ForClause),
    IfClause(IfClause),
}
impl AstNode for ListComprehensionElement {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        LetClause::can_cast(kind) || ForClause::can_cast(kind) || IfClause::can_cast(kind)
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = LetClause::cast(node.clone()) {
            return Some(ListComprehensionElement::LetClause(variant));
        }
        if let Some(variant) = ForClause::cast(node.clone()) {
            return Some(ListComprehensionElement::ForClause(variant));
        }
        if let Some(variant) = IfClause::cast(node.clone()) {
            return Some(ListComprehensionElement::IfClause(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ListComprehensionElement::LetClause(node) => node.syntax(),
            ListComprehensionElement::ForClause(node) => node.syntax(),
            ListComprehensionElement::IfClause(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`LET_CLAUSE`][SyntaxKind::LET_CLAUSE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "LetClause = 'let' '(' assignments:AssignmentsOpt ')' ListComprehensionElementOrExpr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetClause(SyntaxNode);
impl AstNode for LetClause {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::LET_CLAUSE
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if LetClause::can_cast(node.kind()) {
            Some(LetClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl LetClause {
    pub fn let_kw_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::LET_KW)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn assignments_opt(&self) -> Option<AssignmentsOpt> {
        self.0.children().find_map(AssignmentsOpt::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn list_comprehension_element_or_expr(&self) -> Option<ListComprehensionElementOrExpr> {
        self.0
            .children()
            .find_map(ListComprehensionElementOrExpr::cast)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`IF_CLAUSE`][SyntaxKind::IF_CLAUSE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "IfClause = 'if' '(' condition:Expr ')' ListComprehensionElementOrExpr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfClause(SyntaxNode);
impl AstNode for IfClause {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::IF_CLAUSE
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if IfClause::can_cast(node.kind()) {
            Some(IfClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl IfClause {
    pub fn if_kw_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IF_KW)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn list_comprehension_element_or_expr(&self) -> Option<ListComprehensionElementOrExpr> {
        self.0
            .children()
            .find_map(ListComprehensionElementOrExpr::cast)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed `ListComprehensionElementOrExpr` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ListComprehensionElementOrExpr = ListComprehensionElement | Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ListComprehensionElementOrExpr {
    ListComprehensionElement(ListComprehensionElement),
    Expr(Expr),
}
impl AstNode for ListComprehensionElementOrExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        ListComprehensionElement::can_cast(kind) || Expr::can_cast(kind)
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = ListComprehensionElement::cast(node.clone()) {
            return Some(ListComprehensionElementOrExpr::ListComprehensionElement(
                variant,
            ));
        }
        if let Some(variant) = Expr::cast(node.clone()) {
            return Some(ListComprehensionElementOrExpr::Expr(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ListComprehensionElementOrExpr::ListComprehensionElement(node) => node.syntax(),
            ListComprehensionElementOrExpr::Expr(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`ASSIGNMENTS_OPT`][SyntaxKind::ASSIGNMENTS_OPT] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "AssignmentsOpt = Assignments?;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignmentsOpt(SyntaxNode);
impl AstNode for AssignmentsOpt {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ASSIGNMENTS_OPT
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if AssignmentsOpt::can_cast(node.kind()) {
            Some(AssignmentsOpt(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl AssignmentsOpt {
    pub fn assignments_opt(&self) -> Option<Assignments> {
        self.0.children().find_map(Assignments::cast)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`PARAMETERS`][SyntaxKind::PARAMETERS] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Parameters = Parameter (',' Parameter)*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Parameters(SyntaxNode);
impl AstNode for Parameters {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::PARAMETERS
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if Parameters::can_cast(node.kind()) {
            Some(Parameters(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl Parameters {
    pub fn parameters(&self) -> impl Iterator<Item = Parameter> {
        self.0.children().filter_map(Parameter::cast)
    }
    pub fn comma_tokens(&self) -> impl Iterator<Item = SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::COMMA)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`ARGUMENTS`][SyntaxKind::ARGUMENTS] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Arguments = Argument (',' Argument)*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Arguments(SyntaxNode);
impl AstNode for Arguments {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ARGUMENTS
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if Arguments::can_cast(node.kind()) {
            Some(Arguments(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl Arguments {
    pub fn arguments(&self) -> impl Iterator<Item = Argument> {
        self.0.children().filter_map(Argument::cast)
    }
    pub fn comma_tokens(&self) -> impl Iterator<Item = SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::COMMA)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed `Child` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Child = ';' | BracedChildren | ModuleInstantiation;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Child {
    Semicolon(SemicolonToken),
    BracedChildren(BracedChildren),
    ModuleInstantiation(ModuleInstantiation),
}
impl AstNode for Child {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::SEMICOLON
            || BracedChildren::can_cast(kind)
            || ModuleInstantiation::can_cast(kind)
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(token) = SemicolonToken::cast(node.clone()) {
            return Some(Child::Semicolon(token));
        }
        if let Some(variant) = BracedChildren::cast(node.clone()) {
            return Some(Child::BracedChildren(variant));
        }
        if let Some(variant) = ModuleInstantiation::cast(node.clone()) {
            return Some(Child::ModuleInstantiation(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Child::Semicolon(node) => node.syntax(),
            Child::BracedChildren(node) => node.syntax(),
            Child::ModuleInstantiation(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`CHILDREN`][SyntaxKind::CHILDREN] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Children = Child*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Children(SyntaxNode);
impl AstNode for Children {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::CHILDREN
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if Children::can_cast(node.kind()) {
            Some(Children(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl Children {
    pub fn childs(&self) -> impl Iterator<Item = Child> {
        self.0.children().filter_map(Child::cast)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed wrapper around a [`BRACED_CHILDREN`][SyntaxKind::BRACED_CHILDREN] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "BracedChildren = '{' Children '}';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BracedChildren(SyntaxNode);
impl AstNode for BracedChildren {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::BRACED_CHILDREN
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if BracedChildren::can_cast(node.kind()) {
            Some(BracedChildren(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
impl BracedChildren {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_CURLY)
    }
    pub fn children(&self) -> Option<Children> {
        self.0.children().find_map(Children::cast)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_CURLY)
    }
    pub fn span(&self) -> TextRange {
        self.syntax().text_range()
    }
}
#[doc = "A strongly typed `Parameter` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Parameter = variable:'ident' | Assignment;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Parameter {
    Ident(IdentToken),
    Assignment(Assignment),
}
impl AstNode for Parameter {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::IDENT || Assignment::can_cast(kind)
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(token) = IdentToken::cast(node.clone()) {
            return Some(Parameter::Ident(token));
        }
        if let Some(variant) = Assignment::cast(node.clone()) {
            return Some(Parameter::Assignment(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Parameter::Ident(node) => node.syntax(),
            Parameter::Assignment(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed `Argument` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Argument = Expr | Assignment;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Argument {
    Expr(Expr),
    Assignment(Assignment),
}
impl AstNode for Argument {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        Expr::can_cast(kind) || Assignment::can_cast(kind)
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if let Some(variant) = Expr::cast(node.clone()) {
            return Some(Argument::Expr(variant));
        }
        if let Some(variant) = Assignment::cast(node.clone()) {
            return Some(Argument::Assignment(variant));
        }
        None
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Argument::Expr(node) => node.syntax(),
            Argument::Assignment(node) => node.syntax(),
        }
    }
}
#[doc = "The [`SyntaxKind::AND`] token (`&&`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AndToken(SyntaxNode);
impl AndToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::AND)
            .unwrap()
    }
}
impl AstNode for AndToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::AND
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if AndToken::can_cast(node.kind()) {
            Some(AndToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::BANG`] token (`!`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BangToken(SyntaxNode);
impl BangToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::BANG)
            .unwrap()
    }
}
impl AstNode for BangToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::BANG
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if BangToken::can_cast(node.kind()) {
            Some(BangToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::CARET`] token (`^`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CaretToken(SyntaxNode);
impl CaretToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::CARET)
            .unwrap()
    }
}
impl AstNode for CaretToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::CARET
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if CaretToken::can_cast(node.kind()) {
            Some(CaretToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::COLON`] token (`:`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ColonToken(SyntaxNode);
impl ColonToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::COLON)
            .unwrap()
    }
}
impl AstNode for ColonToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::COLON
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if ColonToken::can_cast(node.kind()) {
            Some(ColonToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::COMMA`] token (`,`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CommaToken(SyntaxNode);
impl CommaToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::COMMA)
            .unwrap()
    }
}
impl AstNode for CommaToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::COMMA
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if CommaToken::can_cast(node.kind()) {
            Some(CommaToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::COMMENT`] token."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CommentToken(SyntaxNode);
impl CommentToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::COMMENT)
            .unwrap()
    }
}
impl AstNode for CommentToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::COMMENT
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if CommentToken::can_cast(node.kind()) {
            Some(CommentToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::DOT`] token (`.`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DotToken(SyntaxNode);
impl DotToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::DOT)
            .unwrap()
    }
}
impl AstNode for DotToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::DOT
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if DotToken::can_cast(node.kind()) {
            Some(DotToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::DOUBLE_EQUALS`] token (`==`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DoubleEqualsToken(SyntaxNode);
impl DoubleEqualsToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::DOUBLE_EQUALS)
            .unwrap()
    }
}
impl AstNode for DoubleEqualsToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::DOUBLE_EQUALS
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if DoubleEqualsToken::can_cast(node.kind()) {
            Some(DoubleEqualsToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::ELSE_KW`] token (`else`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ElseKwToken(SyntaxNode);
impl ElseKwToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::ELSE_KW)
            .unwrap()
    }
}
impl AstNode for ElseKwToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ELSE_KW
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if ElseKwToken::can_cast(node.kind()) {
            Some(ElseKwToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::EOF`] token."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EofToken(SyntaxNode);
impl EofToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::EOF)
            .unwrap()
    }
}
impl AstNode for EofToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::EOF
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if EofToken::can_cast(node.kind()) {
            Some(EofToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::EQUALS`] token (`=`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EqualsToken(SyntaxNode);
impl EqualsToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::EQUALS)
            .unwrap()
    }
}
impl AstNode for EqualsToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::EQUALS
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if EqualsToken::can_cast(node.kind()) {
            Some(EqualsToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::ERROR`] token."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ErrorToken(SyntaxNode);
impl ErrorToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::ERROR)
            .unwrap()
    }
}
impl AstNode for ErrorToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ERROR
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if ErrorToken::can_cast(node.kind()) {
            Some(ErrorToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::FALSE_KW`] token (`false`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FalseKwToken(SyntaxNode);
impl FalseKwToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::FALSE_KW)
            .unwrap()
    }
}
impl AstNode for FalseKwToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::FALSE_KW
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if FalseKwToken::can_cast(node.kind()) {
            Some(FalseKwToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::FILE`] token (`file`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FileToken(SyntaxNode);
impl FileToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::FILE)
            .unwrap()
    }
}
impl AstNode for FileToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::FILE
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if FileToken::can_cast(node.kind()) {
            Some(FileToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::FLOAT`] token (`float`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FloatToken(SyntaxNode);
impl FloatToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::FLOAT)
            .unwrap()
    }
}
impl AstNode for FloatToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::FLOAT
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if FloatToken::can_cast(node.kind()) {
            Some(FloatToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::FOR_KW`] token (`for`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForKwToken(SyntaxNode);
impl ForKwToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::FOR_KW)
            .unwrap()
    }
}
impl AstNode for ForKwToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::FOR_KW
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if ForKwToken::can_cast(node.kind()) {
            Some(ForKwToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::FUNCTION_KW`] token (`function`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionKwToken(SyntaxNode);
impl FunctionKwToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::FUNCTION_KW)
            .unwrap()
    }
}
impl AstNode for FunctionKwToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::FUNCTION_KW
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if FunctionKwToken::can_cast(node.kind()) {
            Some(FunctionKwToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::GREATER_THAN`] token (`>`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GreaterThanToken(SyntaxNode);
impl GreaterThanToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::GREATER_THAN)
            .unwrap()
    }
}
impl AstNode for GreaterThanToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::GREATER_THAN
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if GreaterThanToken::can_cast(node.kind()) {
            Some(GreaterThanToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::GREATER_THAN_EQUALS`] token (`>=`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GreaterThanEqualsToken(SyntaxNode);
impl GreaterThanEqualsToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::GREATER_THAN_EQUALS)
            .unwrap()
    }
}
impl AstNode for GreaterThanEqualsToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::GREATER_THAN_EQUALS
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if GreaterThanEqualsToken::can_cast(node.kind()) {
            Some(GreaterThanEqualsToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::HASH`] token (`#`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct HashToken(SyntaxNode);
impl HashToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::HASH)
            .unwrap()
    }
}
impl AstNode for HashToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::HASH
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if HashToken::can_cast(node.kind()) {
            Some(HashToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::IDENT`] token (`ident`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentToken(SyntaxNode);
impl IdentToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::IDENT)
            .unwrap()
    }
}
impl AstNode for IdentToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::IDENT
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if IdentToken::can_cast(node.kind()) {
            Some(IdentToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::IF_KW`] token (`if`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfKwToken(SyntaxNode);
impl IfKwToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::IF_KW)
            .unwrap()
    }
}
impl AstNode for IfKwToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::IF_KW
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if IfKwToken::can_cast(node.kind()) {
            Some(IfKwToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::INCLUDE_KW`] token (`include`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IncludeKwToken(SyntaxNode);
impl IncludeKwToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::INCLUDE_KW)
            .unwrap()
    }
}
impl AstNode for IncludeKwToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::INCLUDE_KW
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if IncludeKwToken::can_cast(node.kind()) {
            Some(IncludeKwToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::INTEGER`] token (`integer`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IntegerToken(SyntaxNode);
impl IntegerToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::INTEGER)
            .unwrap()
    }
}
impl AstNode for IntegerToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::INTEGER
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if IntegerToken::can_cast(node.kind()) {
            Some(IntegerToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::LESS_THAN`] token (`<`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LessThanToken(SyntaxNode);
impl LessThanToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::LESS_THAN)
            .unwrap()
    }
}
impl AstNode for LessThanToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::LESS_THAN
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if LessThanToken::can_cast(node.kind()) {
            Some(LessThanToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::LESS_THAN_EQUALS`] token (`<=`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LessThanEqualsToken(SyntaxNode);
impl LessThanEqualsToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::LESS_THAN_EQUALS)
            .unwrap()
    }
}
impl AstNode for LessThanEqualsToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::LESS_THAN_EQUALS
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if LessThanEqualsToken::can_cast(node.kind()) {
            Some(LessThanEqualsToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::LET_KW`] token (`let`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetKwToken(SyntaxNode);
impl LetKwToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::LET_KW)
            .unwrap()
    }
}
impl AstNode for LetKwToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::LET_KW
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if LetKwToken::can_cast(node.kind()) {
            Some(LetKwToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::L_BRACKET`] token (`[`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LBracketToken(SyntaxNode);
impl LBracketToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::L_BRACKET)
            .unwrap()
    }
}
impl AstNode for LBracketToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::L_BRACKET
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if LBracketToken::can_cast(node.kind()) {
            Some(LBracketToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::L_CURLY`] token (`{`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LCurlyToken(SyntaxNode);
impl LCurlyToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::L_CURLY)
            .unwrap()
    }
}
impl AstNode for LCurlyToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::L_CURLY
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if LCurlyToken::can_cast(node.kind()) {
            Some(LCurlyToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::L_PAREN`] token (`(`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LParenToken(SyntaxNode);
impl LParenToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::L_PAREN)
            .unwrap()
    }
}
impl AstNode for LParenToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::L_PAREN
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if LParenToken::can_cast(node.kind()) {
            Some(LParenToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::MINUS`] token (`-`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MinusToken(SyntaxNode);
impl MinusToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::MINUS)
            .unwrap()
    }
}
impl AstNode for MinusToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::MINUS
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if MinusToken::can_cast(node.kind()) {
            Some(MinusToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::MODULE_KW`] token (`module`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuleKwToken(SyntaxNode);
impl ModuleKwToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::MODULE_KW)
            .unwrap()
    }
}
impl AstNode for ModuleKwToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::MODULE_KW
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if ModuleKwToken::can_cast(node.kind()) {
            Some(ModuleKwToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::NOT_EQUAL`] token (`!=`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NotEqualToken(SyntaxNode);
impl NotEqualToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::NOT_EQUAL)
            .unwrap()
    }
}
impl AstNode for NotEqualToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::NOT_EQUAL
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if NotEqualToken::can_cast(node.kind()) {
            Some(NotEqualToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::OR`] token (`||`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OrToken(SyntaxNode);
impl OrToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::OR)
            .unwrap()
    }
}
impl AstNode for OrToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::OR
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if OrToken::can_cast(node.kind()) {
            Some(OrToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::PERCENT`] token (`%`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PercentToken(SyntaxNode);
impl PercentToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::PERCENT)
            .unwrap()
    }
}
impl AstNode for PercentToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::PERCENT
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if PercentToken::can_cast(node.kind()) {
            Some(PercentToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::PLUS`] token (`+`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PlusToken(SyntaxNode);
impl PlusToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::PLUS)
            .unwrap()
    }
}
impl AstNode for PlusToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::PLUS
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if PlusToken::can_cast(node.kind()) {
            Some(PlusToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::QUESTION_MARK`] token (`?`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct QuestionMarkToken(SyntaxNode);
impl QuestionMarkToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::QUESTION_MARK)
            .unwrap()
    }
}
impl AstNode for QuestionMarkToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::QUESTION_MARK
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if QuestionMarkToken::can_cast(node.kind()) {
            Some(QuestionMarkToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::R_BRACKET`] token (`]`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RBracketToken(SyntaxNode);
impl RBracketToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::R_BRACKET)
            .unwrap()
    }
}
impl AstNode for RBracketToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::R_BRACKET
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if RBracketToken::can_cast(node.kind()) {
            Some(RBracketToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::R_CURLY`] token (`}`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RCurlyToken(SyntaxNode);
impl RCurlyToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::R_CURLY)
            .unwrap()
    }
}
impl AstNode for RCurlyToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::R_CURLY
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if RCurlyToken::can_cast(node.kind()) {
            Some(RCurlyToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::R_PAREN`] token (`)`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RParenToken(SyntaxNode);
impl RParenToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::R_PAREN)
            .unwrap()
    }
}
impl AstNode for RParenToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::R_PAREN
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if RParenToken::can_cast(node.kind()) {
            Some(RParenToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::SEMICOLON`] token (`;`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SemicolonToken(SyntaxNode);
impl SemicolonToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::SEMICOLON)
            .unwrap()
    }
}
impl AstNode for SemicolonToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::SEMICOLON
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if SemicolonToken::can_cast(node.kind()) {
            Some(SemicolonToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::SLASH`] token (`/`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SlashToken(SyntaxNode);
impl SlashToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::SLASH)
            .unwrap()
    }
}
impl AstNode for SlashToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::SLASH
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if SlashToken::can_cast(node.kind()) {
            Some(SlashToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::STAR`] token (`*`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StarToken(SyntaxNode);
impl StarToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::STAR)
            .unwrap()
    }
}
impl AstNode for StarToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::STAR
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if StarToken::can_cast(node.kind()) {
            Some(StarToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::STRING`] token (`string`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StringToken(SyntaxNode);
impl StringToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::STRING)
            .unwrap()
    }
}
impl AstNode for StringToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::STRING
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if StringToken::can_cast(node.kind()) {
            Some(StringToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::TRUE_KW`] token (`true`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TrueKwToken(SyntaxNode);
impl TrueKwToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::TRUE_KW)
            .unwrap()
    }
}
impl AstNode for TrueKwToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::TRUE_KW
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if TrueKwToken::can_cast(node.kind()) {
            Some(TrueKwToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::UNDEF_KW`] token (`undef`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UndefKwToken(SyntaxNode);
impl UndefKwToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::UNDEF_KW)
            .unwrap()
    }
}
impl AstNode for UndefKwToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::UNDEF_KW
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if UndefKwToken::can_cast(node.kind()) {
            Some(UndefKwToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::USE_KW`] token (`use`)."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseKwToken(SyntaxNode);
impl UseKwToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::USE_KW)
            .unwrap()
    }
}
impl AstNode for UseKwToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::USE_KW
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if UseKwToken::can_cast(node.kind()) {
            Some(UseKwToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
#[doc = "The [`SyntaxKind::WHITESPACE`] token."]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhitespaceToken(SyntaxNode);
impl WhitespaceToken {
    #[doc = r" Get the underlying [`SyntaxToken`]."]
    pub fn token(&self) -> SyntaxToken {
        self.0
            .children_with_tokens()
            .filter_map(|element| element.into_token())
            .find(|token| token.kind() == SyntaxKind::WHITESPACE)
            .unwrap()
    }
}
impl AstNode for WhitespaceToken {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::WHITESPACE
    }
    fn cast(node: SyntaxNode) -> Option<Self>
    where
        Self: Sized,
    {
        if WhitespaceToken::can_cast(node.kind()) {
            Some(WhitespaceToken(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.0
    }
}
