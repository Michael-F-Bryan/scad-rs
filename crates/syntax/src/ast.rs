// Generated by `scad_codegen::syntax::tests`. DO NOT EDIT!

use crate::{OpenSCAD, SyntaxKind};
use rowan::{api::SyntaxNode, ast::AstNode, SyntaxToken};
#[doc = "A strongly typed wrapper around a [`SyntaxKind::PACKAGE`]."]
#[doc = "```text"]
#[doc = "Package = Statement*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Package(SyntaxNode<OpenSCAD>);
impl AstNode for Package {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::PACKAGE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Package::can_cast(node.kind()) {
            Some(Package(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "```text"]
#[doc = "Statement = Include | Use | (Assignment ';') | NamedFunctionDefinition | NamedModuleDefinition | ModuleInstantiation;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Statement {
    Include(Include),
    Use(Use),
    Assignment(Assignment),
    Semicolon(SyntaxToken<OpenSCAD>),
    NamedFunctionDefinition(NamedFunctionDefinition),
    NamedModuleDefinition(NamedModuleDefinition),
    ModuleInstantiation(ModuleInstantiation),
}
impl AstNode for Statement {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        Include::can_cast(kind)
            || Use::can_cast(kind)
            || Assignment::can_cast(kind)
            || kind == SyntaxKind::SEMICOLON
            || NamedFunctionDefinition::can_cast(kind)
            || NamedModuleDefinition::can_cast(kind)
            || ModuleInstantiation::can_cast(kind)
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        todo!();
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::INCLUDE`]."]
#[doc = "```text"]
#[doc = "Include = 'include' 'string';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Include(SyntaxNode<OpenSCAD>);
impl AstNode for Include {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::INCLUDE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Include::can_cast(node.kind()) {
            Some(Include(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::USE`]."]
#[doc = "```text"]
#[doc = "Use = 'use' 'file';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Use(SyntaxNode<OpenSCAD>);
impl AstNode for Use {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::USE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Use::can_cast(node.kind()) {
            Some(Use(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::ASSIGNMENT`]."]
#[doc = "```text"]
#[doc = "Assignment = name:'ident' '=' value:Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Assignment(SyntaxNode<OpenSCAD>);
impl AstNode for Assignment {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ASSIGNMENT
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Assignment::can_cast(node.kind()) {
            Some(Assignment(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::NAMED_FUNCTION_DEFINITION`]."]
#[doc = "```text"]
#[doc = "NamedFunctionDefinition = 'function' 'ident' '(' params:Parameters? ')' '=' body:Expr ';';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFunctionDefinition(SyntaxNode<OpenSCAD>);
impl AstNode for NamedFunctionDefinition {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::NAMED_FUNCTION_DEFINITION
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if NamedFunctionDefinition::can_cast(node.kind()) {
            Some(NamedFunctionDefinition(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::NAMED_MODULE_DEFINITION`]."]
#[doc = "```text"]
#[doc = "NamedModuleDefinition = 'module' 'ident' '(' params:Parameters? ')' body:Statement;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedModuleDefinition(SyntaxNode<OpenSCAD>);
impl AstNode for NamedModuleDefinition {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::NAMED_MODULE_DEFINITION
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if NamedModuleDefinition::can_cast(node.kind()) {
            Some(NamedModuleDefinition(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::MODULE_INSTANTIATION`]."]
#[doc = "```text"]
#[doc = "ModuleInstantiation = 'ident' '(' args:Arguments? ')';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuleInstantiation(SyntaxNode<OpenSCAD>);
impl AstNode for ModuleInstantiation {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::MODULE_INSTANTIATION
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if ModuleInstantiation::can_cast(node.kind()) {
            Some(ModuleInstantiation(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::EXPRESSIONS`]."]
#[doc = "```text"]
#[doc = "Expressions = Expr (',' Expr)*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Expressions(SyntaxNode<OpenSCAD>);
impl AstNode for Expressions {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::EXPRESSIONS
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Expressions::can_cast(node.kind()) {
            Some(Expressions(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "```text"]
#[doc = "Expr = LiteralExpr | IndexExpr | ListExpression | RangeExpression | UnaryExpr | TernaryExpr | ParenExpr | ListComprehensionExpr | LetClause | FunctionCall | BinExpr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    LiteralExpr(LiteralExpr),
    IndexExpr(IndexExpr),
    ListExpression(ListExpression),
    RangeExpression(RangeExpression),
    UnaryExpr(UnaryExpr),
    TernaryExpr(TernaryExpr),
    ParenExpr(ParenExpr),
    ListComprehensionExpr(ListComprehensionExpr),
    LetClause(LetClause),
    FunctionCall(FunctionCall),
    BinExpr(BinExpr),
}
impl AstNode for Expr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        LiteralExpr::can_cast(kind)
            || IndexExpr::can_cast(kind)
            || ListExpression::can_cast(kind)
            || RangeExpression::can_cast(kind)
            || UnaryExpr::can_cast(kind)
            || TernaryExpr::can_cast(kind)
            || ParenExpr::can_cast(kind)
            || ListComprehensionExpr::can_cast(kind)
            || LetClause::can_cast(kind)
            || FunctionCall::can_cast(kind)
            || BinExpr::can_cast(kind)
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        todo!();
    }
}
#[doc = "```text"]
#[doc = "LiteralExpr = 'true' | 'false' | 'undef' | 'number' | 'string' | variable:'ident';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum LiteralExpr {
    TrueKw(SyntaxToken<OpenSCAD>),
    FalseKw(SyntaxToken<OpenSCAD>),
    UndefKw(SyntaxToken<OpenSCAD>),
    NumberKw(SyntaxToken<OpenSCAD>),
    String(SyntaxToken<OpenSCAD>),
    Ident(SyntaxToken<OpenSCAD>),
}
impl AstNode for LiteralExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::TRUE_KW
            || kind == SyntaxKind::FALSE_KW
            || kind == SyntaxKind::UNDEF_KW
            || kind == SyntaxKind::NUMBER_KW
            || kind == SyntaxKind::STRING
            || kind == SyntaxKind::IDENT
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        todo!();
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::INDEX_EXPR`]."]
#[doc = "```text"]
#[doc = "IndexExpr = Expr '[' Expr ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr(SyntaxNode<OpenSCAD>);
impl AstNode for IndexExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::INDEX_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if IndexExpr::can_cast(node.kind()) {
            Some(IndexExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::LIST_EXPRESSION`]."]
#[doc = "```text"]
#[doc = "ListExpression = '[' Expressions ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListExpression(SyntaxNode<OpenSCAD>);
impl AstNode for ListExpression {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::LIST_EXPRESSION
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if ListExpression::can_cast(node.kind()) {
            Some(ListExpression(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "```text"]
#[doc = "RangeExpression = RangeExpressionFromTo | RangeExpressionFromToStep;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RangeExpression {
    RangeExpressionFromTo(RangeExpressionFromTo),
    RangeExpressionFromToStep(RangeExpressionFromToStep),
}
impl AstNode for RangeExpression {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        RangeExpressionFromTo::can_cast(kind) || RangeExpressionFromToStep::can_cast(kind)
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        todo!();
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::UNARY_EXPR`]."]
#[doc = "```text"]
#[doc = "UnaryExpr = ('!' | '+' | '-') Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnaryExpr(SyntaxNode<OpenSCAD>);
impl AstNode for UnaryExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::UNARY_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if UnaryExpr::can_cast(node.kind()) {
            Some(UnaryExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::TERNARY_EXPR`]."]
#[doc = "```text"]
#[doc = "TernaryExpr = Expr '?' Expr ':' Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TernaryExpr(SyntaxNode<OpenSCAD>);
impl AstNode for TernaryExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::TERNARY_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if TernaryExpr::can_cast(node.kind()) {
            Some(TernaryExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::PAREN_EXPR`]."]
#[doc = "```text"]
#[doc = "ParenExpr = '(' Expr ')';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr(SyntaxNode<OpenSCAD>);
impl AstNode for ParenExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::PAREN_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if ParenExpr::can_cast(node.kind()) {
            Some(ParenExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::LIST_COMPREHENSION_EXPR`]."]
#[doc = "```text"]
#[doc = "ListComprehensionExpr = '(' ListComprehensionElements ')';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListComprehensionExpr(SyntaxNode<OpenSCAD>);
impl AstNode for ListComprehensionExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::LIST_COMPREHENSION_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if ListComprehensionExpr::can_cast(node.kind()) {
            Some(ListComprehensionExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::LET_CLAUSE`]."]
#[doc = "```text"]
#[doc = "LetClause = 'let' '(' assignments:AssignmentsOpt ')' ListComprehensionElements Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetClause(SyntaxNode<OpenSCAD>);
impl AstNode for LetClause {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::LET_CLAUSE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if LetClause::can_cast(node.kind()) {
            Some(LetClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::FUNCTION_CALL`]."]
#[doc = "```text"]
#[doc = "FunctionCall = 'ident' '(' args:Arguments? ')';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionCall(SyntaxNode<OpenSCAD>);
impl AstNode for FunctionCall {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::FUNCTION_CALL
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if FunctionCall::can_cast(node.kind()) {
            Some(FunctionCall(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::BIN_EXPR`]."]
#[doc = "```text"]
#[doc = "BinExpr = Expr ('+' | '-' | '*' | '/' | '%' | '>=' | '>' | '=' | '<=' | '<' | '&&' | '||') Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr(SyntaxNode<OpenSCAD>);
impl AstNode for BinExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::BIN_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if BinExpr::can_cast(node.kind()) {
            Some(BinExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "```text"]
#[doc = "ListComprehensionElements = LetClause | ForClause | IfClause;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ListComprehensionElements {
    LetClause(LetClause),
    ForClause(ForClause),
    IfClause(IfClause),
}
impl AstNode for ListComprehensionElements {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        LetClause::can_cast(kind) || ForClause::can_cast(kind) || IfClause::can_cast(kind)
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        todo!();
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::RANGE_EXPRESSION_FROM_TO`]."]
#[doc = "```text"]
#[doc = "RangeExpressionFromTo = '[' Expr ':' Expr ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExpressionFromTo(SyntaxNode<OpenSCAD>);
impl AstNode for RangeExpressionFromTo {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::RANGE_EXPRESSION_FROM_TO
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if RangeExpressionFromTo::can_cast(node.kind()) {
            Some(RangeExpressionFromTo(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::RANGE_EXPRESSION_FROM_TO_STEP`]."]
#[doc = "```text"]
#[doc = "RangeExpressionFromToStep = '[' Expr ':' Expr ':' Expr ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExpressionFromToStep(SyntaxNode<OpenSCAD>);
impl AstNode for RangeExpressionFromToStep {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::RANGE_EXPRESSION_FROM_TO_STEP
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if RangeExpressionFromToStep::can_cast(node.kind()) {
            Some(RangeExpressionFromToStep(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::FOR_CLAUSE`]."]
#[doc = "```text"]
#[doc = "ForClause = 'for' '(' assignments:Assignments ')' ListComprehensionElementsOrExpr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForClause(SyntaxNode<OpenSCAD>);
impl AstNode for ForClause {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::FOR_CLAUSE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if ForClause::can_cast(node.kind()) {
            Some(ForClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::IF_CLAUSE`]."]
#[doc = "```text"]
#[doc = "IfClause = 'if' '(' condition:Expr ')' ListComprehensionElementsOrExpr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfClause(SyntaxNode<OpenSCAD>);
impl AstNode for IfClause {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::IF_CLAUSE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if IfClause::can_cast(node.kind()) {
            Some(IfClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "```text"]
#[doc = "ListComprehensionElementsOrExpr = ListComprehensionElements | Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ListComprehensionElementsOrExpr {
    ListComprehensionElements(ListComprehensionElements),
    Expr(Expr),
}
impl AstNode for ListComprehensionElementsOrExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        ListComprehensionElements::can_cast(kind) || Expr::can_cast(kind)
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        todo!();
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::ASSIGNMENTS_OPT`]."]
#[doc = "```text"]
#[doc = "AssignmentsOpt = Assignments?;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignmentsOpt(SyntaxNode<OpenSCAD>);
impl AstNode for AssignmentsOpt {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ASSIGNMENTS_OPT
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if AssignmentsOpt::can_cast(node.kind()) {
            Some(AssignmentsOpt(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::ASSIGNMENTS`]."]
#[doc = "```text"]
#[doc = "Assignments = Assignment (',' Assignment)*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Assignments(SyntaxNode<OpenSCAD>);
impl AstNode for Assignments {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ASSIGNMENTS
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Assignments::can_cast(node.kind()) {
            Some(Assignments(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::PARAMETERS`]."]
#[doc = "```text"]
#[doc = "Parameters = Parameter (',' Parameter)*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Parameters(SyntaxNode<OpenSCAD>);
impl AstNode for Parameters {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::PARAMETERS
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Parameters::can_cast(node.kind()) {
            Some(Parameters(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::ARGUMENTS`]."]
#[doc = "```text"]
#[doc = "Arguments = Argument (',' Argument)*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Arguments(SyntaxNode<OpenSCAD>);
impl AstNode for Arguments {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ARGUMENTS
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Arguments::can_cast(node.kind()) {
            Some(Arguments(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::CHILDREN`]."]
#[doc = "```text"]
#[doc = "Children = Child*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Children(SyntaxNode<OpenSCAD>);
impl AstNode for Children {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::CHILDREN
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Children::can_cast(node.kind()) {
            Some(Children(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "```text"]
#[doc = "Child = ';' | BracedChildren | ModuleInstantiation;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Child {
    Semicolon(SyntaxToken<OpenSCAD>),
    BracedChildren(BracedChildren),
    ModuleInstantiation(ModuleInstantiation),
}
impl AstNode for Child {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::SEMICOLON
            || BracedChildren::can_cast(kind)
            || ModuleInstantiation::can_cast(kind)
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        todo!();
    }
}
#[doc = "A strongly typed wrapper around a [`SyntaxKind::BRACED_CHILDREN`]."]
#[doc = "```text"]
#[doc = "BracedChildren = '{' Children '}';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BracedChildren(SyntaxNode<OpenSCAD>);
impl AstNode for BracedChildren {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::BRACED_CHILDREN
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if BracedChildren::can_cast(node.kind()) {
            Some(BracedChildren(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
#[doc = "```text"]
#[doc = "Parameter = variable:'ident' | Assignment;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Parameter {
    Ident(SyntaxToken<OpenSCAD>),
    Assignment(Assignment),
}
impl AstNode for Parameter {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::IDENT || Assignment::can_cast(kind)
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        todo!();
    }
}
#[doc = "```text"]
#[doc = "Argument = Expr | Assignment;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Argument {
    Expr(Expr),
    Assignment(Assignment),
}
impl AstNode for Argument {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        Expr::can_cast(kind) || Assignment::can_cast(kind)
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        todo!();
    }
}
