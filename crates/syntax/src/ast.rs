// Generated by `scad-codegen`. DO NOT EDIT!

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Statement {
    Include(Include),
    Use(Use),
    Assignment(Assignment),
    NamedFunctionDefinition(NamedFunctionDefinition),
    NamedModuleDefinition(NamedModuleDefinition),
    ModuleInstantiation(ModuleInstantiation),
}
impl Statement {
    pub fn as_include(&self) -> Option<Include> {
        match self {
            Statement::Include(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_use(&self) -> Option<Use> {
        match self {
            Statement::Use(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_assignment(&self) -> Option<Assignment> {
        match self {
            Statement::Assignment(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_named_function_definition(&self) -> Option<NamedFunctionDefinition> {
        match self {
            Statement::NamedFunctionDefinition(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_named_module_definition(&self) -> Option<NamedModuleDefinition> {
        match self {
            Statement::NamedModuleDefinition(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_module_instantiation(&self) -> Option<ModuleInstantiation> {
        match self {
            Statement::ModuleInstantiation(node) => Some(node.clone()),
            _ => None,
        }
    }
}
impl rowan::ast::AstNode for Statement {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        <Include as rowan::ast::AstNode>::can_cast(kind)
            || <Use as rowan::ast::AstNode>::can_cast(kind)
            || <Assignment as rowan::ast::AstNode>::can_cast(kind)
            || <NamedFunctionDefinition as rowan::ast::AstNode>::can_cast(kind)
            || <NamedModuleDefinition as rowan::ast::AstNode>::can_cast(kind)
            || <ModuleInstantiation as rowan::ast::AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if let Some(node) = <Include as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <Use as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <Assignment as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <NamedFunctionDefinition as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <NamedModuleDefinition as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <ModuleInstantiation as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        None
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        match self {
            Statement::Include(node) => node.syntax(),
            Statement::Use(node) => node.syntax(),
            Statement::Assignment(node) => node.syntax(),
            Statement::NamedFunctionDefinition(node) => node.syntax(),
            Statement::NamedModuleDefinition(node) => node.syntax(),
            Statement::ModuleInstantiation(node) => node.syntax(),
        }
    }
}
impl From<Include> for Statement {
    fn from(value: Include) -> Statement {
        Statement::Include(value)
    }
}
impl From<Use> for Statement {
    fn from(value: Use) -> Statement {
        Statement::Use(value)
    }
}
impl From<Assignment> for Statement {
    fn from(value: Assignment) -> Statement {
        Statement::Assignment(value)
    }
}
impl From<NamedFunctionDefinition> for Statement {
    fn from(value: NamedFunctionDefinition) -> Statement {
        Statement::NamedFunctionDefinition(value)
    }
}
impl From<NamedModuleDefinition> for Statement {
    fn from(value: NamedModuleDefinition) -> Statement {
        Statement::NamedModuleDefinition(value)
    }
}
impl From<ModuleInstantiation> for Statement {
    fn from(value: ModuleInstantiation) -> Statement {
        Statement::ModuleInstantiation(value)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    LiteralExpr(LiteralExpr),
    IndexExpr(IndexExpr),
    ListExpression(ListExpression),
    RangeExpression(RangeExpression),
    UnaryExpr(UnaryExpr),
    TernaryExpr(TernaryExpr),
    ParenExpr(ParenExpr),
    ListComprehensionExpr(ListComprehensionExpr),
    LetClause(LetClause),
    FunctionCall(FunctionCall),
    BinExpr(BinExpr),
}
impl Expr {
    pub fn as_literal_expr(&self) -> Option<LiteralExpr> {
        match self {
            Expr::LiteralExpr(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_index_expr(&self) -> Option<IndexExpr> {
        match self {
            Expr::IndexExpr(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_list_expression(&self) -> Option<ListExpression> {
        match self {
            Expr::ListExpression(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_range_expression(&self) -> Option<RangeExpression> {
        match self {
            Expr::RangeExpression(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_unary_expr(&self) -> Option<UnaryExpr> {
        match self {
            Expr::UnaryExpr(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_ternary_expr(&self) -> Option<TernaryExpr> {
        match self {
            Expr::TernaryExpr(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_paren_expr(&self) -> Option<ParenExpr> {
        match self {
            Expr::ParenExpr(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_list_comprehension_expr(&self) -> Option<ListComprehensionExpr> {
        match self {
            Expr::ListComprehensionExpr(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_let_clause(&self) -> Option<LetClause> {
        match self {
            Expr::LetClause(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_function_call(&self) -> Option<FunctionCall> {
        match self {
            Expr::FunctionCall(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_bin_expr(&self) -> Option<BinExpr> {
        match self {
            Expr::BinExpr(node) => Some(node.clone()),
            _ => None,
        }
    }
}
impl rowan::ast::AstNode for Expr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        <LiteralExpr as rowan::ast::AstNode>::can_cast(kind)
            || <IndexExpr as rowan::ast::AstNode>::can_cast(kind)
            || <ListExpression as rowan::ast::AstNode>::can_cast(kind)
            || <RangeExpression as rowan::ast::AstNode>::can_cast(kind)
            || <UnaryExpr as rowan::ast::AstNode>::can_cast(kind)
            || <TernaryExpr as rowan::ast::AstNode>::can_cast(kind)
            || <ParenExpr as rowan::ast::AstNode>::can_cast(kind)
            || <ListComprehensionExpr as rowan::ast::AstNode>::can_cast(kind)
            || <LetClause as rowan::ast::AstNode>::can_cast(kind)
            || <FunctionCall as rowan::ast::AstNode>::can_cast(kind)
            || <BinExpr as rowan::ast::AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if let Some(node) = <LiteralExpr as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <IndexExpr as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <ListExpression as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <RangeExpression as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <UnaryExpr as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <TernaryExpr as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <ParenExpr as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <ListComprehensionExpr as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <LetClause as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <FunctionCall as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <BinExpr as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        None
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        match self {
            Expr::LiteralExpr(node) => node.syntax(),
            Expr::IndexExpr(node) => node.syntax(),
            Expr::ListExpression(node) => node.syntax(),
            Expr::RangeExpression(node) => node.syntax(),
            Expr::UnaryExpr(node) => node.syntax(),
            Expr::TernaryExpr(node) => node.syntax(),
            Expr::ParenExpr(node) => node.syntax(),
            Expr::ListComprehensionExpr(node) => node.syntax(),
            Expr::LetClause(node) => node.syntax(),
            Expr::FunctionCall(node) => node.syntax(),
            Expr::BinExpr(node) => node.syntax(),
        }
    }
}
impl From<LiteralExpr> for Expr {
    fn from(value: LiteralExpr) -> Expr {
        Expr::LiteralExpr(value)
    }
}
impl From<IndexExpr> for Expr {
    fn from(value: IndexExpr) -> Expr {
        Expr::IndexExpr(value)
    }
}
impl From<ListExpression> for Expr {
    fn from(value: ListExpression) -> Expr {
        Expr::ListExpression(value)
    }
}
impl From<RangeExpression> for Expr {
    fn from(value: RangeExpression) -> Expr {
        Expr::RangeExpression(value)
    }
}
impl From<UnaryExpr> for Expr {
    fn from(value: UnaryExpr) -> Expr {
        Expr::UnaryExpr(value)
    }
}
impl From<TernaryExpr> for Expr {
    fn from(value: TernaryExpr) -> Expr {
        Expr::TernaryExpr(value)
    }
}
impl From<ParenExpr> for Expr {
    fn from(value: ParenExpr) -> Expr {
        Expr::ParenExpr(value)
    }
}
impl From<ListComprehensionExpr> for Expr {
    fn from(value: ListComprehensionExpr) -> Expr {
        Expr::ListComprehensionExpr(value)
    }
}
impl From<LetClause> for Expr {
    fn from(value: LetClause) -> Expr {
        Expr::LetClause(value)
    }
}
impl From<FunctionCall> for Expr {
    fn from(value: FunctionCall) -> Expr {
        Expr::FunctionCall(value)
    }
}
impl From<BinExpr> for Expr {
    fn from(value: BinExpr) -> Expr {
        Expr::BinExpr(value)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum LiteralExpr {
    True(rowan::api::SyntaxNode<crate::OpenSCAD>),
    False(rowan::api::SyntaxNode<crate::OpenSCAD>),
    Undef(rowan::api::SyntaxNode<crate::OpenSCAD>),
    Number(rowan::api::SyntaxNode<crate::OpenSCAD>),
    String(rowan::api::SyntaxNode<crate::OpenSCAD>),
    Variable(rowan::api::SyntaxNode<crate::OpenSCAD>),
}
impl LiteralExpr {
    pub fn as_true(&self) -> Option<rowan::api::SyntaxNode<crate::OpenSCAD>> {
        match self {
            LiteralExpr::True(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_false(&self) -> Option<rowan::api::SyntaxNode<crate::OpenSCAD>> {
        match self {
            LiteralExpr::False(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_undef(&self) -> Option<rowan::api::SyntaxNode<crate::OpenSCAD>> {
        match self {
            LiteralExpr::Undef(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_number(&self) -> Option<rowan::api::SyntaxNode<crate::OpenSCAD>> {
        match self {
            LiteralExpr::Number(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_string(&self) -> Option<rowan::api::SyntaxNode<crate::OpenSCAD>> {
        match self {
            LiteralExpr::String(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_variable(&self) -> Option<rowan::api::SyntaxNode<crate::OpenSCAD>> {
        match self {
            LiteralExpr::Variable(node) => Some(node.clone()),
            _ => None,
        }
    }
}
impl rowan::ast::AstNode for LiteralExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::TRUE
            || kind == crate::SyntaxKind::FALSE
            || kind == crate::SyntaxKind::UNDEF
            || kind == crate::SyntaxKind::NUMBER
            || kind == crate::SyntaxKind::STRING
            || kind == crate::SyntaxKind::IDENT
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if node.kind() == crate::SyntaxKind::TRUE {
            return Some(Self::True(node));
        }
        if node.kind() == crate::SyntaxKind::FALSE {
            return Some(Self::False(node));
        }
        if node.kind() == crate::SyntaxKind::UNDEF {
            return Some(Self::Undef(node));
        }
        if node.kind() == crate::SyntaxKind::NUMBER {
            return Some(Self::Number(node));
        }
        if node.kind() == crate::SyntaxKind::STRING {
            return Some(Self::String(node));
        }
        if node.kind() == crate::SyntaxKind::IDENT {
            return Some(Self::Ident(node));
        }
        None
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        match self {
            LiteralExpr::True(node) => node.syntax(),
            LiteralExpr::False(node) => node.syntax(),
            LiteralExpr::Undef(node) => node.syntax(),
            LiteralExpr::Number(node) => node.syntax(),
            LiteralExpr::String(node) => node.syntax(),
            LiteralExpr::Variable(node) => node.syntax(),
        }
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RangeExpression {
    RangeExpressionFromTo(RangeExpressionFromTo),
    RangeExpressionFromToStep(RangeExpressionFromToStep),
}
impl RangeExpression {
    pub fn as_range_expression_from_to(&self) -> Option<RangeExpressionFromTo> {
        match self {
            RangeExpression::RangeExpressionFromTo(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_range_expression_from_to_step(&self) -> Option<RangeExpressionFromToStep> {
        match self {
            RangeExpression::RangeExpressionFromToStep(node) => Some(node.clone()),
            _ => None,
        }
    }
}
impl rowan::ast::AstNode for RangeExpression {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        <RangeExpressionFromTo as rowan::ast::AstNode>::can_cast(kind)
            || <RangeExpressionFromToStep as rowan::ast::AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if let Some(node) = <RangeExpressionFromTo as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <RangeExpressionFromToStep as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        None
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        match self {
            RangeExpression::RangeExpressionFromTo(node) => node.syntax(),
            RangeExpression::RangeExpressionFromToStep(node) => node.syntax(),
        }
    }
}
impl From<RangeExpressionFromTo> for RangeExpression {
    fn from(value: RangeExpressionFromTo) -> RangeExpression {
        RangeExpression::RangeExpressionFromTo(value)
    }
}
impl From<RangeExpressionFromToStep> for RangeExpression {
    fn from(value: RangeExpressionFromToStep) -> RangeExpression {
        RangeExpression::RangeExpressionFromToStep(value)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ListComprehensionElements {
    LetClause(LetClause),
    ForClause(ForClause),
    IfClause(IfClause),
}
impl ListComprehensionElements {
    pub fn as_let_clause(&self) -> Option<LetClause> {
        match self {
            ListComprehensionElements::LetClause(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_for_clause(&self) -> Option<ForClause> {
        match self {
            ListComprehensionElements::ForClause(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_if_clause(&self) -> Option<IfClause> {
        match self {
            ListComprehensionElements::IfClause(node) => Some(node.clone()),
            _ => None,
        }
    }
}
impl rowan::ast::AstNode for ListComprehensionElements {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        <LetClause as rowan::ast::AstNode>::can_cast(kind)
            || <ForClause as rowan::ast::AstNode>::can_cast(kind)
            || <IfClause as rowan::ast::AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if let Some(node) = <LetClause as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <ForClause as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <IfClause as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        None
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        match self {
            ListComprehensionElements::LetClause(node) => node.syntax(),
            ListComprehensionElements::ForClause(node) => node.syntax(),
            ListComprehensionElements::IfClause(node) => node.syntax(),
        }
    }
}
impl From<LetClause> for ListComprehensionElements {
    fn from(value: LetClause) -> ListComprehensionElements {
        ListComprehensionElements::LetClause(value)
    }
}
impl From<ForClause> for ListComprehensionElements {
    fn from(value: ForClause) -> ListComprehensionElements {
        ListComprehensionElements::ForClause(value)
    }
}
impl From<IfClause> for ListComprehensionElements {
    fn from(value: IfClause) -> ListComprehensionElements {
        ListComprehensionElements::IfClause(value)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ListComprehensionElementsOrExpr {
    ListComprehensionElements(ListComprehensionElements),
    Expr(Expr),
}
impl ListComprehensionElementsOrExpr {
    pub fn as_list_comprehension_elements(&self) -> Option<ListComprehensionElements> {
        match self {
            ListComprehensionElementsOrExpr::ListComprehensionElements(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_expr(&self) -> Option<Expr> {
        match self {
            ListComprehensionElementsOrExpr::Expr(node) => Some(node.clone()),
            _ => None,
        }
    }
}
impl rowan::ast::AstNode for ListComprehensionElementsOrExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        <ListComprehensionElements as rowan::ast::AstNode>::can_cast(kind)
            || <Expr as rowan::ast::AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if let Some(node) = <ListComprehensionElements as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <Expr as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        None
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        match self {
            ListComprehensionElementsOrExpr::ListComprehensionElements(node) => node.syntax(),
            ListComprehensionElementsOrExpr::Expr(node) => node.syntax(),
        }
    }
}
impl From<ListComprehensionElements> for ListComprehensionElementsOrExpr {
    fn from(value: ListComprehensionElements) -> ListComprehensionElementsOrExpr {
        ListComprehensionElementsOrExpr::ListComprehensionElements(value)
    }
}
impl From<Expr> for ListComprehensionElementsOrExpr {
    fn from(value: Expr) -> ListComprehensionElementsOrExpr {
        ListComprehensionElementsOrExpr::Expr(value)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Child {
    Semicolon(rowan::api::SyntaxNode<crate::OpenSCAD>),
    BracedChildren(BracedChildren),
    ModuleInstantiation(ModuleInstantiation),
}
impl Child {
    pub fn as_semicolon(&self) -> Option<rowan::api::SyntaxNode<crate::OpenSCAD>> {
        match self {
            Child::Semicolon(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_braced_children(&self) -> Option<BracedChildren> {
        match self {
            Child::BracedChildren(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_module_instantiation(&self) -> Option<ModuleInstantiation> {
        match self {
            Child::ModuleInstantiation(node) => Some(node.clone()),
            _ => None,
        }
    }
}
impl rowan::ast::AstNode for Child {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::SEMICOLON
            || <BracedChildren as rowan::ast::AstNode>::can_cast(kind)
            || <ModuleInstantiation as rowan::ast::AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if node.kind() == crate::SyntaxKind::SEMICOLON {
            return Some(Self::Semicolon(node));
        }
        if let Some(node) = <BracedChildren as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <ModuleInstantiation as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        None
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        match self {
            Child::Semicolon(node) => node.syntax(),
            Child::BracedChildren(node) => node.syntax(),
            Child::ModuleInstantiation(node) => node.syntax(),
        }
    }
}
impl From<BracedChildren> for Child {
    fn from(value: BracedChildren) -> Child {
        Child::BracedChildren(value)
    }
}
impl From<ModuleInstantiation> for Child {
    fn from(value: ModuleInstantiation) -> Child {
        Child::ModuleInstantiation(value)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Parameter {
    Variable(rowan::api::SyntaxNode<crate::OpenSCAD>),
    Assignment(Assignment),
}
impl Parameter {
    pub fn as_variable(&self) -> Option<rowan::api::SyntaxNode<crate::OpenSCAD>> {
        match self {
            Parameter::Variable(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_assignment(&self) -> Option<Assignment> {
        match self {
            Parameter::Assignment(node) => Some(node.clone()),
            _ => None,
        }
    }
}
impl rowan::ast::AstNode for Parameter {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::IDENT || <Assignment as rowan::ast::AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if node.kind() == crate::SyntaxKind::IDENT {
            return Some(Self::Ident(node));
        }
        if let Some(node) = <Assignment as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        None
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        match self {
            Parameter::Variable(node) => node.syntax(),
            Parameter::Assignment(node) => node.syntax(),
        }
    }
}
impl From<Assignment> for Parameter {
    fn from(value: Assignment) -> Parameter {
        Parameter::Assignment(value)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Argument {
    Expr(Expr),
    Assignment(Assignment),
}
impl Argument {
    pub fn as_expr(&self) -> Option<Expr> {
        match self {
            Argument::Expr(node) => Some(node.clone()),
            _ => None,
        }
    }
    pub fn as_assignment(&self) -> Option<Assignment> {
        match self {
            Argument::Assignment(node) => Some(node.clone()),
            _ => None,
        }
    }
}
impl rowan::ast::AstNode for Argument {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        <Expr as rowan::ast::AstNode>::can_cast(kind)
            || <Assignment as rowan::ast::AstNode>::can_cast(kind)
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if let Some(node) = <Expr as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        if let Some(node) = <Assignment as rowan::ast::AstNode>::cast(node.clone()) {
            return Some(node.into());
        }
        None
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        match self {
            Argument::Expr(node) => node.syntax(),
            Argument::Assignment(node) => node.syntax(),
        }
    }
}
impl From<Expr> for Argument {
    fn from(value: Expr) -> Argument {
        Argument::Expr(value)
    }
}
impl From<Assignment> for Argument {
    fn from(value: Assignment) -> Argument {
        Argument::Assignment(value)
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Package(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Package {
    pub fn statements(&self) -> impl Iterator<Item = Statement> {
        rowan::ast::support::children(&self.0)
    }
}
impl rowan::ast::AstNode for Package {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::PACKAGE
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Package::can_cast(node.kind()) {
            Some(Package(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Include(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Include {
    pub fn include(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::INCLUDE)
    }
    pub fn string(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::STRING)
    }
}
impl rowan::ast::AstNode for Include {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::INCLUDE
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Include::can_cast(node.kind()) {
            Some(Include(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Use(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Use {
    pub fn r#use(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::USE)
    }
    pub fn file(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::FILE)
    }
}
impl rowan::ast::AstNode for Use {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::USE
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Use::can_cast(node.kind()) {
            Some(Use(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Assignment(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Assignment {
    pub fn name(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::IDENT)
    }
    pub fn equals(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::EQUALS)
    }
    pub fn value(&self) -> Option<Expr> {
        rowan::ast::support::child(&self.0)
    }
}
impl rowan::ast::AstNode for Assignment {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::ASSIGNMENT
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Assignment::can_cast(node.kind()) {
            Some(Assignment(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFunctionDefinition(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl NamedFunctionDefinition {
    pub fn function(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::FUNCTION)
    }
    pub fn ident(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::IDENT)
    }
    pub fn l_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::L_PAREN)
    }
    pub fn params_opt(&self) -> Option<Parameters> {
        rowan::ast::support::child(&self.0)
    }
    pub fn r_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::R_PAREN)
    }
    pub fn equals(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::EQUALS)
    }
    pub fn body(&self) -> Option<Expr> {
        rowan::ast::support::child(&self.0)
    }
    pub fn semicolon(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::SEMICOLON)
    }
}
impl rowan::ast::AstNode for NamedFunctionDefinition {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::NAMED_FUNCTION_DEFINITION
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if NamedFunctionDefinition::can_cast(node.kind()) {
            Some(NamedFunctionDefinition(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedModuleDefinition(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl NamedModuleDefinition {
    pub fn module(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::MODULE)
    }
    pub fn ident(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::IDENT)
    }
    pub fn l_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::L_PAREN)
    }
    pub fn params_opt(&self) -> Option<Parameters> {
        rowan::ast::support::child(&self.0)
    }
    pub fn r_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::R_PAREN)
    }
    pub fn body(&self) -> Option<Statement> {
        rowan::ast::support::child(&self.0)
    }
}
impl rowan::ast::AstNode for NamedModuleDefinition {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::NAMED_MODULE_DEFINITION
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if NamedModuleDefinition::can_cast(node.kind()) {
            Some(NamedModuleDefinition(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuleInstantiation(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl ModuleInstantiation {
    pub fn ident(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::IDENT)
    }
    pub fn l_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::L_PAREN)
    }
    pub fn args_opt(&self) -> Option<Arguments> {
        rowan::ast::support::child(&self.0)
    }
    pub fn r_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::R_PAREN)
    }
}
impl rowan::ast::AstNode for ModuleInstantiation {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::MODULE_INSTANTIATION
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if ModuleInstantiation::can_cast(node.kind()) {
            Some(ModuleInstantiation(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Expressions(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Expressions {
    pub fn expr(&self) -> Option<Expr> {
        rowan::ast::support::child(&self.0)
    }
    pub fn commas(&self) -> impl Iterator<Item = rowan::api::SyntaxToken<crate::OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|it| it.into_token())
            .filter(|tok| tok.kind() == crate::SyntaxKind::COMMA)
    }
}
impl rowan::ast::AstNode for Expressions {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::EXPRESSIONS
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Expressions::can_cast(node.kind()) {
            Some(Expressions(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl IndexExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        rowan::ast::support::children(&self.0)
    }
    pub fn l_bracket(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::L_BRACKET)
    }
    pub fn r_bracket(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::R_BRACKET)
    }
}
impl rowan::ast::AstNode for IndexExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::INDEX_EXPR
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if IndexExpr::can_cast(node.kind()) {
            Some(IndexExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListExpression(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl ListExpression {
    pub fn l_bracket(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::L_BRACKET)
    }
    pub fn expressions(&self) -> Option<Expressions> {
        rowan::ast::support::child(&self.0)
    }
    pub fn r_bracket(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::R_BRACKET)
    }
}
impl rowan::ast::AstNode for ListExpression {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::LIST_EXPRESSION
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if ListExpression::can_cast(node.kind()) {
            Some(ListExpression(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnaryExpr(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl UnaryExpr {
    pub fn expr(&self) -> Option<Expr> {
        rowan::ast::support::child(&self.0)
    }
}
impl rowan::ast::AstNode for UnaryExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::UNARY_EXPR
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if UnaryExpr::can_cast(node.kind()) {
            Some(UnaryExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TernaryExpr(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl TernaryExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        rowan::ast::support::children(&self.0)
    }
    pub fn question_mark(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::QUESTION_MARK)
    }
    pub fn colon(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::COLON)
    }
}
impl rowan::ast::AstNode for TernaryExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::TERNARY_EXPR
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if TernaryExpr::can_cast(node.kind()) {
            Some(TernaryExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl ParenExpr {
    pub fn l_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::L_PAREN)
    }
    pub fn expr(&self) -> Option<Expr> {
        rowan::ast::support::child(&self.0)
    }
    pub fn r_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::R_PAREN)
    }
}
impl rowan::ast::AstNode for ParenExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::PAREN_EXPR
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if ParenExpr::can_cast(node.kind()) {
            Some(ParenExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListComprehensionExpr(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl ListComprehensionExpr {
    pub fn l_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::L_PAREN)
    }
    pub fn list_comprehension_elements(&self) -> Option<ListComprehensionElements> {
        rowan::ast::support::child(&self.0)
    }
    pub fn r_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::R_PAREN)
    }
}
impl rowan::ast::AstNode for ListComprehensionExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::LIST_COMPREHENSION_EXPR
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if ListComprehensionExpr::can_cast(node.kind()) {
            Some(ListComprehensionExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetClause(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl LetClause {
    pub fn r#let(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::LET)
    }
    pub fn l_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::L_PAREN)
    }
    pub fn assignments(&self) -> Option<AssignmentsOpt> {
        rowan::ast::support::child(&self.0)
    }
    pub fn r_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::R_PAREN)
    }
    pub fn list_comprehension_elements(&self) -> Option<ListComprehensionElements> {
        rowan::ast::support::child(&self.0)
    }
    pub fn expr(&self) -> Option<Expr> {
        rowan::ast::support::child(&self.0)
    }
}
impl rowan::ast::AstNode for LetClause {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::LET_CLAUSE
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if LetClause::can_cast(node.kind()) {
            Some(LetClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionCall(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl FunctionCall {
    pub fn ident(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::IDENT)
    }
    pub fn l_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::L_PAREN)
    }
    pub fn args_opt(&self) -> Option<Arguments> {
        rowan::ast::support::child(&self.0)
    }
    pub fn r_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::R_PAREN)
    }
}
impl rowan::ast::AstNode for FunctionCall {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::FUNCTION_CALL
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if FunctionCall::can_cast(node.kind()) {
            Some(FunctionCall(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl BinExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        rowan::ast::support::children(&self.0)
    }
}
impl rowan::ast::AstNode for BinExpr {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::BIN_EXPR
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if BinExpr::can_cast(node.kind()) {
            Some(BinExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExpressionFromTo(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl RangeExpressionFromTo {
    pub fn l_bracket(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::L_BRACKET)
    }
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        rowan::ast::support::children(&self.0)
    }
    pub fn colon(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::COLON)
    }
    pub fn r_bracket(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::R_BRACKET)
    }
}
impl rowan::ast::AstNode for RangeExpressionFromTo {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::RANGE_EXPRESSION_FROM_TO
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if RangeExpressionFromTo::can_cast(node.kind()) {
            Some(RangeExpressionFromTo(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExpressionFromToStep(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl RangeExpressionFromToStep {
    pub fn l_bracket(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::L_BRACKET)
    }
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        rowan::ast::support::children(&self.0)
    }
    pub fn colons(&self) -> impl Iterator<Item = rowan::api::SyntaxToken<crate::OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|it| it.into_token())
            .filter(|tok| tok.kind() == crate::SyntaxKind::COLON)
    }
    pub fn r_bracket(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::R_BRACKET)
    }
}
impl rowan::ast::AstNode for RangeExpressionFromToStep {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::RANGE_EXPRESSION_FROM_TO_STEP
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if RangeExpressionFromToStep::can_cast(node.kind()) {
            Some(RangeExpressionFromToStep(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForClause(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl ForClause {
    pub fn r#for(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::FOR)
    }
    pub fn l_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::L_PAREN)
    }
    pub fn assignments(&self) -> Option<Assignments> {
        rowan::ast::support::child(&self.0)
    }
    pub fn r_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::R_PAREN)
    }
    pub fn list_comprehension_elements_or_expr(&self) -> Option<ListComprehensionElementsOrExpr> {
        rowan::ast::support::child(&self.0)
    }
}
impl rowan::ast::AstNode for ForClause {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::FOR_CLAUSE
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if ForClause::can_cast(node.kind()) {
            Some(ForClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfClause(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl IfClause {
    pub fn r#if(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::IF)
    }
    pub fn l_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::L_PAREN)
    }
    pub fn condition(&self) -> Option<Expr> {
        rowan::ast::support::child(&self.0)
    }
    pub fn r_paren(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::R_PAREN)
    }
    pub fn list_comprehension_elements_or_expr(&self) -> Option<ListComprehensionElementsOrExpr> {
        rowan::ast::support::child(&self.0)
    }
}
impl rowan::ast::AstNode for IfClause {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::IF_CLAUSE
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if IfClause::can_cast(node.kind()) {
            Some(IfClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignmentsOpt(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl AssignmentsOpt {
    pub fn assignments(&self) -> Option<Assignments> {
        rowan::ast::support::child(&self.0)
    }
}
impl rowan::ast::AstNode for AssignmentsOpt {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::ASSIGNMENTS_OPT
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if AssignmentsOpt::can_cast(node.kind()) {
            Some(AssignmentsOpt(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Assignments(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Assignments {
    pub fn assignment(&self) -> Option<Assignment> {
        rowan::ast::support::child(&self.0)
    }
    pub fn commas(&self) -> impl Iterator<Item = rowan::api::SyntaxToken<crate::OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|it| it.into_token())
            .filter(|tok| tok.kind() == crate::SyntaxKind::COMMA)
    }
}
impl rowan::ast::AstNode for Assignments {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::ASSIGNMENTS
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Assignments::can_cast(node.kind()) {
            Some(Assignments(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Parameters(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Parameters {
    pub fn parameter(&self) -> Option<Parameter> {
        rowan::ast::support::child(&self.0)
    }
    pub fn commas(&self) -> impl Iterator<Item = rowan::api::SyntaxToken<crate::OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|it| it.into_token())
            .filter(|tok| tok.kind() == crate::SyntaxKind::COMMA)
    }
}
impl rowan::ast::AstNode for Parameters {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::PARAMETERS
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Parameters::can_cast(node.kind()) {
            Some(Parameters(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Arguments(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Arguments {
    pub fn argument(&self) -> Option<Argument> {
        rowan::ast::support::child(&self.0)
    }
    pub fn commas(&self) -> impl Iterator<Item = rowan::api::SyntaxToken<crate::OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|it| it.into_token())
            .filter(|tok| tok.kind() == crate::SyntaxKind::COMMA)
    }
}
impl rowan::ast::AstNode for Arguments {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::ARGUMENTS
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Arguments::can_cast(node.kind()) {
            Some(Arguments(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Children(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl Children {
    pub fn childs(&self) -> impl Iterator<Item = Child> {
        rowan::ast::support::children(&self.0)
    }
}
impl rowan::ast::AstNode for Children {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::CHILDREN
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if Children::can_cast(node.kind()) {
            Some(Children(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BracedChildren(rowan::api::SyntaxNode<crate::OpenSCAD>);
impl BracedChildren {
    pub fn l_curly(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::L_CURLY)
    }
    pub fn children(&self) -> Option<Children> {
        rowan::ast::support::child(&self.0)
    }
    pub fn r_curly(&self) -> Option<rowan::api::SyntaxToken<crate::OpenSCAD>> {
        rowan::ast::support::token(&self.0, crate::SyntaxKind::R_CURLY)
    }
}
impl rowan::ast::AstNode for BracedChildren {
    type Language = crate::OpenSCAD;
    fn can_cast(kind: crate::SyntaxKind) -> bool {
        kind == crate::SyntaxKind::BRACED_CHILDREN
    }
    fn cast(node: rowan::api::SyntaxNode<crate::OpenSCAD>) -> Option<Self> {
        if BracedChildren::can_cast(node.kind()) {
            Some(BracedChildren(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &rowan::api::SyntaxNode<crate::OpenSCAD> {
        &self.0
    }
}
