// Generated by `scad_codegen::syntax::tests`. DO NOT EDIT!

#![doc = r" Automatically generated, strongly-typed [`AstNode`]s."]
use crate::{OpenSCAD, SyntaxKind};
use rowan::{api::SyntaxNode, ast::AstNode, SyntaxToken};
#[doc = "A strongly typed wrapper around a [`PACKAGE`][SyntaxKind::PACKAGE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Package = Statement*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Package(SyntaxNode<OpenSCAD>);
impl AstNode for Package {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::PACKAGE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Package::can_cast(node.kind()) {
            Some(Package(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Package {
    pub fn statements(&self) -> impl Iterator<Item = Statement> {
        self.0.children().filter_map(Statement::cast)
    }
}
#[doc = "A strongly typed `Statement` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Statement = Include | Use | AssignmentStatement | NamedFunctionDefinition | NamedModuleDefinition | ModuleInstantiation;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Statement {
    Include(Include),
    Use(Use),
    AssignmentStatement(AssignmentStatement),
    NamedFunctionDefinition(NamedFunctionDefinition),
    NamedModuleDefinition(NamedModuleDefinition),
    ModuleInstantiation(ModuleInstantiation),
}
impl AstNode for Statement {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        Include::can_cast(kind)
            || Use::can_cast(kind)
            || AssignmentStatement::can_cast(kind)
            || NamedFunctionDefinition::can_cast(kind)
            || NamedModuleDefinition::can_cast(kind)
            || ModuleInstantiation::can_cast(kind)
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            Statement::Include(node) => node.syntax(),
            Statement::Use(node) => node.syntax(),
            Statement::AssignmentStatement(node) => node.syntax(),
            Statement::NamedFunctionDefinition(node) => node.syntax(),
            Statement::NamedModuleDefinition(node) => node.syntax(),
            Statement::ModuleInstantiation(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`INCLUDE`][SyntaxKind::INCLUDE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Include = 'include' 'file';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Include(SyntaxNode<OpenSCAD>);
impl AstNode for Include {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::INCLUDE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Include::can_cast(node.kind()) {
            Some(Include(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Include {
    pub fn include_kw_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::INCLUDE_KW)
    }
    pub fn file_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::FILE)
    }
}
#[doc = "A strongly typed wrapper around a [`USE`][SyntaxKind::USE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Use = 'use' 'file';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Use(SyntaxNode<OpenSCAD>);
impl AstNode for Use {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::USE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Use::can_cast(node.kind()) {
            Some(Use(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Use {
    pub fn use_kw_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::USE_KW)
    }
    pub fn file_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::FILE)
    }
}
#[doc = "A strongly typed wrapper around a [`ASSIGNMENT_STATEMENT`][SyntaxKind::ASSIGNMENT_STATEMENT] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "AssignmentStatement = Assignment ';';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignmentStatement(SyntaxNode<OpenSCAD>);
impl AstNode for AssignmentStatement {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ASSIGNMENT_STATEMENT
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if AssignmentStatement::can_cast(node.kind()) {
            Some(AssignmentStatement(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl AssignmentStatement {
    pub fn assignment(&self) -> Option<Assignment> {
        self.0.children().find_map(Assignment::cast)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::SEMICOLON)
    }
}
#[doc = "A strongly typed wrapper around a [`NAMED_FUNCTION_DEFINITION`][SyntaxKind::NAMED_FUNCTION_DEFINITION] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "NamedFunctionDefinition = 'function' 'ident' '(' params:Parameters? ')' '=' body:Expr ';';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFunctionDefinition(SyntaxNode<OpenSCAD>);
impl AstNode for NamedFunctionDefinition {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::NAMED_FUNCTION_DEFINITION
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if NamedFunctionDefinition::can_cast(node.kind()) {
            Some(NamedFunctionDefinition(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl NamedFunctionDefinition {
    pub fn function_kw_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::FUNCTION_KW)
    }
    pub fn ident_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IDENT)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn parameters_opt(&self) -> Option<Parameters> {
        self.0.children().find_map(Parameters::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn equals_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::EQUALS)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
    pub fn semicolon_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::SEMICOLON)
    }
}
#[doc = "A strongly typed wrapper around a [`NAMED_MODULE_DEFINITION`][SyntaxKind::NAMED_MODULE_DEFINITION] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "NamedModuleDefinition = 'module' 'ident' '(' params:Parameters? ')' body:Statement;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedModuleDefinition(SyntaxNode<OpenSCAD>);
impl AstNode for NamedModuleDefinition {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::NAMED_MODULE_DEFINITION
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if NamedModuleDefinition::can_cast(node.kind()) {
            Some(NamedModuleDefinition(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl NamedModuleDefinition {
    pub fn module_kw_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::MODULE_KW)
    }
    pub fn ident_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IDENT)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn parameters_opt(&self) -> Option<Parameters> {
        self.0.children().find_map(Parameters::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn statement(&self) -> Option<Statement> {
        self.0.children().find_map(Statement::cast)
    }
}
#[doc = "A strongly typed wrapper around a [`MODULE_INSTANTIATION`][SyntaxKind::MODULE_INSTANTIATION] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ModuleInstantiation = 'ident' '(' args:Arguments? ')';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuleInstantiation(SyntaxNode<OpenSCAD>);
impl AstNode for ModuleInstantiation {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::MODULE_INSTANTIATION
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if ModuleInstantiation::can_cast(node.kind()) {
            Some(ModuleInstantiation(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl ModuleInstantiation {
    pub fn ident_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IDENT)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn arguments_opt(&self) -> Option<Arguments> {
        self.0.children().find_map(Arguments::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
}
#[doc = "A strongly typed wrapper around a [`ASSIGNMENT`][SyntaxKind::ASSIGNMENT] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Assignment = name:'ident' '=' value:Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Assignment(SyntaxNode<OpenSCAD>);
impl AstNode for Assignment {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ASSIGNMENT
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Assignment::can_cast(node.kind()) {
            Some(Assignment(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Assignment {
    pub fn ident_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IDENT)
    }
    pub fn equals_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::EQUALS)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
}
#[doc = "A strongly typed wrapper around a [`EXPRESSIONS`][SyntaxKind::EXPRESSIONS] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Expressions = Expr (',' Expr)*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Expressions(SyntaxNode<OpenSCAD>);
impl AstNode for Expressions {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::EXPRESSIONS
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Expressions::can_cast(node.kind()) {
            Some(Expressions(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Expressions {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn comma_tokens(&self) -> impl Iterator<Item = SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::COMMA)
    }
}
#[doc = "A strongly typed `Expr` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Expr = LiteralExpr | IndexExpr | ListExpression | RangeExpression | UnaryExpr | TernaryExpr | ParenExpr | ListComprehensionExpr | LetClause | FunctionCall | BinExpr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    LiteralExpr(LiteralExpr),
    IndexExpr(IndexExpr),
    ListExpression(ListExpression),
    RangeExpression(RangeExpression),
    UnaryExpr(UnaryExpr),
    TernaryExpr(TernaryExpr),
    ParenExpr(ParenExpr),
    ListComprehensionExpr(ListComprehensionExpr),
    LetClause(LetClause),
    FunctionCall(FunctionCall),
    BinExpr(BinExpr),
}
impl AstNode for Expr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        LiteralExpr::can_cast(kind)
            || IndexExpr::can_cast(kind)
            || ListExpression::can_cast(kind)
            || RangeExpression::can_cast(kind)
            || UnaryExpr::can_cast(kind)
            || TernaryExpr::can_cast(kind)
            || ParenExpr::can_cast(kind)
            || ListComprehensionExpr::can_cast(kind)
            || LetClause::can_cast(kind)
            || FunctionCall::can_cast(kind)
            || BinExpr::can_cast(kind)
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            Expr::LiteralExpr(node) => node.syntax(),
            Expr::IndexExpr(node) => node.syntax(),
            Expr::ListExpression(node) => node.syntax(),
            Expr::RangeExpression(node) => node.syntax(),
            Expr::UnaryExpr(node) => node.syntax(),
            Expr::TernaryExpr(node) => node.syntax(),
            Expr::ParenExpr(node) => node.syntax(),
            Expr::ListComprehensionExpr(node) => node.syntax(),
            Expr::LetClause(node) => node.syntax(),
            Expr::FunctionCall(node) => node.syntax(),
            Expr::BinExpr(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed `LiteralExpr` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "LiteralExpr = 'true' | 'false' | 'undef' | 'number' | 'string' | variable:'ident';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum LiteralExpr {
    TrueKw(SyntaxNode<OpenSCAD>),
    FalseKw(SyntaxNode<OpenSCAD>),
    UndefKw(SyntaxNode<OpenSCAD>),
    NumberKw(SyntaxNode<OpenSCAD>),
    String(SyntaxNode<OpenSCAD>),
    Ident(SyntaxNode<OpenSCAD>),
}
impl AstNode for LiteralExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::TRUE_KW
            || kind == SyntaxKind::FALSE_KW
            || kind == SyntaxKind::UNDEF_KW
            || kind == SyntaxKind::NUMBER_KW
            || kind == SyntaxKind::STRING
            || kind == SyntaxKind::IDENT
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            LiteralExpr::TrueKw(node) => node,
            LiteralExpr::FalseKw(node) => node,
            LiteralExpr::UndefKw(node) => node,
            LiteralExpr::NumberKw(node) => node,
            LiteralExpr::String(node) => node,
            LiteralExpr::Ident(node) => node,
        }
    }
}
#[doc = "A strongly typed wrapper around a [`INDEX_EXPR`][SyntaxKind::INDEX_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "IndexExpr = Expr '[' Expr ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr(SyntaxNode<OpenSCAD>);
impl AstNode for IndexExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::INDEX_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if IndexExpr::can_cast(node.kind()) {
            Some(IndexExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl IndexExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn l_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_BRACKET)
    }
    pub fn r_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_BRACKET)
    }
}
#[doc = "A strongly typed wrapper around a [`LIST_EXPRESSION`][SyntaxKind::LIST_EXPRESSION] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ListExpression = '[' Expressions ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListExpression(SyntaxNode<OpenSCAD>);
impl AstNode for ListExpression {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::LIST_EXPRESSION
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if ListExpression::can_cast(node.kind()) {
            Some(ListExpression(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl ListExpression {
    pub fn l_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_BRACKET)
    }
    pub fn expressions(&self) -> Option<Expressions> {
        self.0.children().find_map(Expressions::cast)
    }
    pub fn r_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_BRACKET)
    }
}
#[doc = "A strongly typed `RangeExpression` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "RangeExpression = RangeExpressionFromTo | RangeExpressionFromToStep;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RangeExpression {
    RangeExpressionFromTo(RangeExpressionFromTo),
    RangeExpressionFromToStep(RangeExpressionFromToStep),
}
impl AstNode for RangeExpression {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        RangeExpressionFromTo::can_cast(kind) || RangeExpressionFromToStep::can_cast(kind)
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            RangeExpression::RangeExpressionFromTo(node) => node.syntax(),
            RangeExpression::RangeExpressionFromToStep(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`UNARY_EXPR`][SyntaxKind::UNARY_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "UnaryExpr = ('!' | '+' | '-') Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnaryExpr(SyntaxNode<OpenSCAD>);
impl AstNode for UnaryExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::UNARY_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if UnaryExpr::can_cast(node.kind()) {
            Some(UnaryExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl UnaryExpr {
    pub fn bang_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::BANG)
    }
    pub fn plus_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::PLUS)
    }
    pub fn minus_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::MINUS)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
}
#[doc = "A strongly typed wrapper around a [`TERNARY_EXPR`][SyntaxKind::TERNARY_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "TernaryExpr = Expr '?' Expr ':' Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TernaryExpr(SyntaxNode<OpenSCAD>);
impl AstNode for TernaryExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::TERNARY_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if TernaryExpr::can_cast(node.kind()) {
            Some(TernaryExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl TernaryExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn question_mark_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::QUESTION_MARK)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::COLON)
    }
}
#[doc = "A strongly typed wrapper around a [`PAREN_EXPR`][SyntaxKind::PAREN_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ParenExpr = '(' Expr ')';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr(SyntaxNode<OpenSCAD>);
impl AstNode for ParenExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::PAREN_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if ParenExpr::can_cast(node.kind()) {
            Some(ParenExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl ParenExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
}
#[doc = "A strongly typed wrapper around a [`LIST_COMPREHENSION_EXPR`][SyntaxKind::LIST_COMPREHENSION_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ListComprehensionExpr = '(' ListComprehensionElements ')';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListComprehensionExpr(SyntaxNode<OpenSCAD>);
impl AstNode for ListComprehensionExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::LIST_COMPREHENSION_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if ListComprehensionExpr::can_cast(node.kind()) {
            Some(ListComprehensionExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl ListComprehensionExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn list_comprehension_elements(&self) -> Option<ListComprehensionElements> {
        self.0.children().find_map(ListComprehensionElements::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
}
#[doc = "A strongly typed wrapper around a [`LET_CLAUSE`][SyntaxKind::LET_CLAUSE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "LetClause = 'let' '(' assignments:AssignmentsOpt ')' ListComprehensionElements Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetClause(SyntaxNode<OpenSCAD>);
impl AstNode for LetClause {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::LET_CLAUSE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if LetClause::can_cast(node.kind()) {
            Some(LetClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl LetClause {
    pub fn let_kw_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::LET_KW)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn assignments_opt(&self) -> Option<AssignmentsOpt> {
        self.0.children().find_map(AssignmentsOpt::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn list_comprehension_elements(&self) -> Option<ListComprehensionElements> {
        self.0.children().find_map(ListComprehensionElements::cast)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
}
#[doc = "A strongly typed wrapper around a [`FUNCTION_CALL`][SyntaxKind::FUNCTION_CALL] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "FunctionCall = 'ident' '(' args:Arguments? ')';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionCall(SyntaxNode<OpenSCAD>);
impl AstNode for FunctionCall {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::FUNCTION_CALL
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if FunctionCall::can_cast(node.kind()) {
            Some(FunctionCall(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl FunctionCall {
    pub fn ident_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IDENT)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn arguments_opt(&self) -> Option<Arguments> {
        self.0.children().find_map(Arguments::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
}
#[doc = "A strongly typed wrapper around a [`BIN_EXPR`][SyntaxKind::BIN_EXPR] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "BinExpr = Expr ('+' | '-' | '*' | '/' | '%' | '^' | '>=' | '>' | '=' | '<=' | '<' | '&&' | '||') Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr(SyntaxNode<OpenSCAD>);
impl AstNode for BinExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::BIN_EXPR
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if BinExpr::can_cast(node.kind()) {
            Some(BinExpr(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl BinExpr {
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn plus_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::PLUS)
    }
    pub fn minus_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::MINUS)
    }
    pub fn star_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::STAR)
    }
    pub fn slash_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::SLASH)
    }
    pub fn percent_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::PERCENT)
    }
    pub fn caret_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::CARET)
    }
    pub fn greater_than_equals_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::GREATER_THAN_EQUALS)
    }
    pub fn greater_than_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::GREATER_THAN)
    }
    pub fn equals_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::EQUALS)
    }
    pub fn less_than_equals_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::LESS_THAN_EQUALS)
    }
    pub fn less_than_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::LESS_THAN)
    }
    pub fn and_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::AND)
    }
    pub fn or_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::OR)
    }
}
#[doc = "A strongly typed `ListComprehensionElements` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ListComprehensionElements = LetClause | ForClause | IfClause;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ListComprehensionElements {
    LetClause(LetClause),
    ForClause(ForClause),
    IfClause(IfClause),
}
impl AstNode for ListComprehensionElements {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        LetClause::can_cast(kind) || ForClause::can_cast(kind) || IfClause::can_cast(kind)
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            ListComprehensionElements::LetClause(node) => node.syntax(),
            ListComprehensionElements::ForClause(node) => node.syntax(),
            ListComprehensionElements::IfClause(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`RANGE_EXPRESSION_FROM_TO`][SyntaxKind::RANGE_EXPRESSION_FROM_TO] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "RangeExpressionFromTo = '[' Expr ':' Expr ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExpressionFromTo(SyntaxNode<OpenSCAD>);
impl AstNode for RangeExpressionFromTo {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::RANGE_EXPRESSION_FROM_TO
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if RangeExpressionFromTo::can_cast(node.kind()) {
            Some(RangeExpressionFromTo(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl RangeExpressionFromTo {
    pub fn l_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_BRACKET)
    }
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::COLON)
    }
    pub fn r_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_BRACKET)
    }
}
#[doc = "A strongly typed wrapper around a [`RANGE_EXPRESSION_FROM_TO_STEP`][SyntaxKind::RANGE_EXPRESSION_FROM_TO_STEP] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "RangeExpressionFromToStep = '[' Expr ':' Expr ':' Expr ']';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExpressionFromToStep(SyntaxNode<OpenSCAD>);
impl AstNode for RangeExpressionFromToStep {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::RANGE_EXPRESSION_FROM_TO_STEP
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if RangeExpressionFromToStep::can_cast(node.kind()) {
            Some(RangeExpressionFromToStep(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl RangeExpressionFromToStep {
    pub fn l_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_BRACKET)
    }
    pub fn exprs(&self) -> impl Iterator<Item = Expr> {
        self.0.children().filter_map(Expr::cast)
    }
    pub fn colon_tokens(&self) -> impl Iterator<Item = SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::COLON)
    }
    pub fn r_bracket_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_BRACKET)
    }
}
#[doc = "A strongly typed wrapper around a [`FOR_CLAUSE`][SyntaxKind::FOR_CLAUSE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ForClause = 'for' '(' assignments:Assignments ')' ListComprehensionElementsOrExpr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForClause(SyntaxNode<OpenSCAD>);
impl AstNode for ForClause {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::FOR_CLAUSE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if ForClause::can_cast(node.kind()) {
            Some(ForClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl ForClause {
    pub fn for_kw_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::FOR_KW)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn assignments(&self) -> Option<Assignments> {
        self.0.children().find_map(Assignments::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn list_comprehension_elements_or_expr(&self) -> Option<ListComprehensionElementsOrExpr> {
        self.0
            .children()
            .find_map(ListComprehensionElementsOrExpr::cast)
    }
}
#[doc = "A strongly typed wrapper around a [`IF_CLAUSE`][SyntaxKind::IF_CLAUSE] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "IfClause = 'if' '(' condition:Expr ')' ListComprehensionElementsOrExpr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfClause(SyntaxNode<OpenSCAD>);
impl AstNode for IfClause {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::IF_CLAUSE
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if IfClause::can_cast(node.kind()) {
            Some(IfClause(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl IfClause {
    pub fn if_kw_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::IF_KW)
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_PAREN)
    }
    pub fn expr(&self) -> Option<Expr> {
        self.0.children().find_map(Expr::cast)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_PAREN)
    }
    pub fn list_comprehension_elements_or_expr(&self) -> Option<ListComprehensionElementsOrExpr> {
        self.0
            .children()
            .find_map(ListComprehensionElementsOrExpr::cast)
    }
}
#[doc = "A strongly typed `ListComprehensionElementsOrExpr` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "ListComprehensionElementsOrExpr = ListComprehensionElements | Expr;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ListComprehensionElementsOrExpr {
    ListComprehensionElements(ListComprehensionElements),
    Expr(Expr),
}
impl AstNode for ListComprehensionElementsOrExpr {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        ListComprehensionElements::can_cast(kind) || Expr::can_cast(kind)
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            ListComprehensionElementsOrExpr::ListComprehensionElements(node) => node.syntax(),
            ListComprehensionElementsOrExpr::Expr(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`ASSIGNMENTS_OPT`][SyntaxKind::ASSIGNMENTS_OPT] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "AssignmentsOpt = Assignments?;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignmentsOpt(SyntaxNode<OpenSCAD>);
impl AstNode for AssignmentsOpt {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ASSIGNMENTS_OPT
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if AssignmentsOpt::can_cast(node.kind()) {
            Some(AssignmentsOpt(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl AssignmentsOpt {
    pub fn assignments_opt(&self) -> Option<Assignments> {
        self.0.children().find_map(Assignments::cast)
    }
}
#[doc = "A strongly typed wrapper around a [`ASSIGNMENTS`][SyntaxKind::ASSIGNMENTS] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Assignments = Assignment (',' Assignment)*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Assignments(SyntaxNode<OpenSCAD>);
impl AstNode for Assignments {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ASSIGNMENTS
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Assignments::can_cast(node.kind()) {
            Some(Assignments(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Assignments {
    pub fn assignments(&self) -> impl Iterator<Item = Assignment> {
        self.0.children().filter_map(Assignment::cast)
    }
    pub fn comma_tokens(&self) -> impl Iterator<Item = SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::COMMA)
    }
}
#[doc = "A strongly typed wrapper around a [`PARAMETERS`][SyntaxKind::PARAMETERS] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Parameters = Parameter (',' Parameter)*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Parameters(SyntaxNode<OpenSCAD>);
impl AstNode for Parameters {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::PARAMETERS
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Parameters::can_cast(node.kind()) {
            Some(Parameters(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Parameters {
    pub fn parameters(&self) -> impl Iterator<Item = Parameter> {
        self.0.children().filter_map(Parameter::cast)
    }
    pub fn comma_tokens(&self) -> impl Iterator<Item = SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::COMMA)
    }
}
#[doc = "A strongly typed wrapper around a [`ARGUMENTS`][SyntaxKind::ARGUMENTS] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Arguments = Argument (',' Argument)*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Arguments(SyntaxNode<OpenSCAD>);
impl AstNode for Arguments {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::ARGUMENTS
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Arguments::can_cast(node.kind()) {
            Some(Arguments(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Arguments {
    pub fn arguments(&self) -> impl Iterator<Item = Argument> {
        self.0.children().filter_map(Argument::cast)
    }
    pub fn comma_tokens(&self) -> impl Iterator<Item = SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .filter(|tok| tok.kind() == SyntaxKind::COMMA)
    }
}
#[doc = "A strongly typed wrapper around a [`CHILDREN`][SyntaxKind::CHILDREN] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Children = Child*;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Children(SyntaxNode<OpenSCAD>);
impl AstNode for Children {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::CHILDREN
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if Children::can_cast(node.kind()) {
            Some(Children(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl Children {
    pub fn childs(&self) -> impl Iterator<Item = Child> {
        self.0.children().filter_map(Child::cast)
    }
}
#[doc = "A strongly typed `Child` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Child = ';' | BracedChildren | ModuleInstantiation;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Child {
    Semicolon(SyntaxNode<OpenSCAD>),
    BracedChildren(BracedChildren),
    ModuleInstantiation(ModuleInstantiation),
}
impl AstNode for Child {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::SEMICOLON
            || BracedChildren::can_cast(kind)
            || ModuleInstantiation::can_cast(kind)
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            Child::Semicolon(node) => node,
            Child::BracedChildren(node) => node.syntax(),
            Child::ModuleInstantiation(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed wrapper around a [`BRACED_CHILDREN`][SyntaxKind::BRACED_CHILDREN] node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "BracedChildren = '{' Children '}';\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BracedChildren(SyntaxNode<OpenSCAD>);
impl AstNode for BracedChildren {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::BRACED_CHILDREN
    }
    fn cast(node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        if BracedChildren::can_cast(node.kind()) {
            Some(BracedChildren(node))
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        &self.0
    }
}
impl BracedChildren {
    pub fn l_curly_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::L_CURLY)
    }
    pub fn children(&self) -> Option<Children> {
        self.0.children().find_map(Children::cast)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken<OpenSCAD>> {
        self.0
            .children_with_tokens()
            .filter_map(|t| t.into_token())
            .find(|tok| tok.kind() == SyntaxKind::R_CURLY)
    }
}
#[doc = "A strongly typed `Parameter` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Parameter = variable:'ident' | Assignment;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Parameter {
    Ident(SyntaxNode<OpenSCAD>),
    Assignment(Assignment),
}
impl AstNode for Parameter {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        kind == SyntaxKind::IDENT || Assignment::can_cast(kind)
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            Parameter::Ident(node) => node,
            Parameter::Assignment(node) => node.syntax(),
        }
    }
}
#[doc = "A strongly typed `Argument` node."]
#[doc = ""]
#[doc = "Grammar:"]
#[doc = "```text"]
#[doc = "Argument = Expr | Assignment;\n"]
#[doc = "```"]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Argument {
    Expr(Expr),
    Assignment(Assignment),
}
impl AstNode for Argument {
    type Language = OpenSCAD;
    fn can_cast(kind: SyntaxKind) -> bool
    where
        Self: Sized,
    {
        Expr::can_cast(kind) || Assignment::can_cast(kind)
    }
    fn cast(_node: SyntaxNode<OpenSCAD>) -> Option<Self>
    where
        Self: Sized,
    {
        todo!();
    }
    fn syntax(&self) -> &SyntaxNode<OpenSCAD> {
        match self {
            Argument::Expr(node) => node.syntax(),
            Argument::Assignment(node) => node.syntax(),
        }
    }
}
