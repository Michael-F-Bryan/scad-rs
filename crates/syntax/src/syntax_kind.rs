// Generated by `scad-codegen`. DO NOT EDIT!

#[doc = r" The different types of terminals and non-terminals in the"]
#[doc = r" OpenSCAD language grammar."]
#[derive(
    Debug,
    Copy,
    Clone,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    num_derive :: FromPrimitive,
    num_derive :: ToPrimitive,
)]
#[repr(u16)]
#[allow(nonstandard_style)]
#[non_exhaustive]
pub enum SyntaxKind {
    #[doc = "The `&&` symbol."]
    AND,
    #[doc = "The `!` symbol."]
    BANG,
    #[doc = "The `^` symbol."]
    CARET,
    #[doc = "The `:` symbol."]
    COLON,
    #[doc = "The `,` symbol."]
    COMMA,
    #[doc = "A comment."]
    COMMENT,
    #[doc = "The `.` symbol."]
    DOT,
    #[doc = "End of input."]
    EOF,
    #[doc = "The `=` symbol."]
    EQUALS,
    #[doc = "A lexer error."]
    ERROR,
    #[doc = "The `false` keyword."]
    FALSE_KW,
    #[doc = "The `file` keyword."]
    FILE_KW,
    #[doc = "A float literal"]
    FLOAT,
    #[doc = "The `for` keyword."]
    FOR_KW,
    #[doc = "The `function` keyword."]
    FUNCTION_KW,
    #[doc = "The `>` symbol."]
    GREATER_THAN,
    #[doc = "The `>=` symbol."]
    GREATER_THAN_EQUALS,
    #[doc = "An identifier."]
    IDENT,
    #[doc = "The `if` keyword."]
    IF_KW,
    #[doc = "The `include` keyword."]
    INCLUDE_KW,
    #[doc = "An integer literal"]
    INTEGER,
    #[doc = "The `<` symbol."]
    LESS_THAN,
    #[doc = "The `<=` symbol."]
    LESS_THAN_EQUALS,
    #[doc = "The `let` keyword."]
    LET_KW,
    #[doc = "The `[` symbol."]
    L_BRACKET,
    #[doc = "The `{` symbol."]
    L_CURLY,
    #[doc = "The `(` symbol."]
    L_PAREN,
    #[doc = "The `-` symbol."]
    MINUS,
    #[doc = "The `module` keyword."]
    MODULE_KW,
    #[doc = "The `number` keyword."]
    NUMBER_KW,
    #[doc = "The `||` symbol."]
    OR,
    #[doc = "The `%` symbol."]
    PERCENT,
    #[doc = "The `+` symbol."]
    PLUS,
    #[doc = "The `?` symbol."]
    QUESTION_MARK,
    #[doc = "The `]` symbol."]
    R_BRACKET,
    #[doc = "The `}` symbol."]
    R_CURLY,
    #[doc = "The `)` symbol."]
    R_PAREN,
    #[doc = "The `;` symbol."]
    SEMICOLON,
    #[doc = "The `/` symbol."]
    SLASH,
    #[doc = "The `*` symbol."]
    STAR,
    #[doc = "A string literal"]
    STRING,
    #[doc = "The `true` keyword."]
    TRUE_KW,
    #[doc = "The `undef` keyword."]
    UNDEF_KW,
    #[doc = "The `use` keyword."]
    USE_KW,
    #[doc = "One or more whitespace characters (spaces, tabs, newlines, etc.)."]
    WHITESPACE,
    PACKAGE,
    STATEMENT,
    INCLUDE,
    USE,
    ASSIGNMENT,
    NAMED_FUNCTION_DEFINITION,
    NAMED_MODULE_DEFINITION,
    MODULE_INSTANTIATION,
    EXPRESSIONS,
    EXPR,
    LITERAL_EXPR,
    INDEX_EXPR,
    LIST_EXPRESSION,
    RANGE_EXPRESSION,
    UNARY_EXPR,
    TERNARY_EXPR,
    PAREN_EXPR,
    LIST_COMPREHENSION_EXPR,
    LET_CLAUSE,
    FUNCTION_CALL,
    BIN_EXPR,
    LIST_COMPREHENSION_ELEMENTS,
    RANGE_EXPRESSION_FROM_TO,
    RANGE_EXPRESSION_FROM_TO_STEP,
    FOR_CLAUSE,
    IF_CLAUSE,
    LIST_COMPREHENSION_ELEMENTS_OR_EXPR,
    ASSIGNMENTS_OPT,
    ASSIGNMENTS,
    PARAMETERS,
    ARGUMENTS,
    CHILDREN,
    CHILD,
    BRACED_CHILDREN,
    PARAMETER,
    ARGUMENT,
}
impl SyntaxKind {
    #[doc = r" All the possible [`SyntaxKind`] variants."]
    pub const VARIANTS: [SyntaxKind; 81usize] = [
        SyntaxKind::AND,
        SyntaxKind::BANG,
        SyntaxKind::CARET,
        SyntaxKind::COLON,
        SyntaxKind::COMMA,
        SyntaxKind::COMMENT,
        SyntaxKind::DOT,
        SyntaxKind::EOF,
        SyntaxKind::EQUALS,
        SyntaxKind::ERROR,
        SyntaxKind::FALSE_KW,
        SyntaxKind::FILE_KW,
        SyntaxKind::FLOAT,
        SyntaxKind::FOR_KW,
        SyntaxKind::FUNCTION_KW,
        SyntaxKind::GREATER_THAN,
        SyntaxKind::GREATER_THAN_EQUALS,
        SyntaxKind::IDENT,
        SyntaxKind::IF_KW,
        SyntaxKind::INCLUDE_KW,
        SyntaxKind::INTEGER,
        SyntaxKind::LESS_THAN,
        SyntaxKind::LESS_THAN_EQUALS,
        SyntaxKind::LET_KW,
        SyntaxKind::L_BRACKET,
        SyntaxKind::L_CURLY,
        SyntaxKind::L_PAREN,
        SyntaxKind::MINUS,
        SyntaxKind::MODULE_KW,
        SyntaxKind::NUMBER_KW,
        SyntaxKind::OR,
        SyntaxKind::PERCENT,
        SyntaxKind::PLUS,
        SyntaxKind::QUESTION_MARK,
        SyntaxKind::R_BRACKET,
        SyntaxKind::R_CURLY,
        SyntaxKind::R_PAREN,
        SyntaxKind::SEMICOLON,
        SyntaxKind::SLASH,
        SyntaxKind::STAR,
        SyntaxKind::STRING,
        SyntaxKind::TRUE_KW,
        SyntaxKind::UNDEF_KW,
        SyntaxKind::USE_KW,
        SyntaxKind::WHITESPACE,
        SyntaxKind::PACKAGE,
        SyntaxKind::STATEMENT,
        SyntaxKind::INCLUDE,
        SyntaxKind::USE,
        SyntaxKind::ASSIGNMENT,
        SyntaxKind::NAMED_FUNCTION_DEFINITION,
        SyntaxKind::NAMED_MODULE_DEFINITION,
        SyntaxKind::MODULE_INSTANTIATION,
        SyntaxKind::EXPRESSIONS,
        SyntaxKind::EXPR,
        SyntaxKind::LITERAL_EXPR,
        SyntaxKind::INDEX_EXPR,
        SyntaxKind::LIST_EXPRESSION,
        SyntaxKind::RANGE_EXPRESSION,
        SyntaxKind::UNARY_EXPR,
        SyntaxKind::TERNARY_EXPR,
        SyntaxKind::PAREN_EXPR,
        SyntaxKind::LIST_COMPREHENSION_EXPR,
        SyntaxKind::LET_CLAUSE,
        SyntaxKind::FUNCTION_CALL,
        SyntaxKind::BIN_EXPR,
        SyntaxKind::LIST_COMPREHENSION_ELEMENTS,
        SyntaxKind::RANGE_EXPRESSION_FROM_TO,
        SyntaxKind::RANGE_EXPRESSION_FROM_TO_STEP,
        SyntaxKind::FOR_CLAUSE,
        SyntaxKind::IF_CLAUSE,
        SyntaxKind::LIST_COMPREHENSION_ELEMENTS_OR_EXPR,
        SyntaxKind::ASSIGNMENTS_OPT,
        SyntaxKind::ASSIGNMENTS,
        SyntaxKind::PARAMETERS,
        SyntaxKind::ARGUMENTS,
        SyntaxKind::CHILDREN,
        SyntaxKind::CHILD,
        SyntaxKind::BRACED_CHILDREN,
        SyntaxKind::PARAMETER,
        SyntaxKind::ARGUMENT,
    ];
    #[doc = r" Is this [`SyntaxKind`] a piece of punctuation?"]
    #[doc = r""]
    #[doc = r" ```rust"]
    #[doc = r" # use scad_syntax::T;"]
    #[doc = r" let kind = T![;];"]
    #[doc = r" assert!(kind.is_punctuation())"]
    #[doc = r" ```"]
    pub const fn is_punctuation(self) -> bool {
        matches!(
            self,
            SyntaxKind::AND
                | SyntaxKind::BANG
                | SyntaxKind::CARET
                | SyntaxKind::COLON
                | SyntaxKind::COMMA
                | SyntaxKind::DOT
                | SyntaxKind::EQUALS
                | SyntaxKind::GREATER_THAN
                | SyntaxKind::GREATER_THAN_EQUALS
                | SyntaxKind::LESS_THAN
                | SyntaxKind::LESS_THAN_EQUALS
                | SyntaxKind::L_BRACKET
                | SyntaxKind::L_CURLY
                | SyntaxKind::L_PAREN
                | SyntaxKind::MINUS
                | SyntaxKind::OR
                | SyntaxKind::PERCENT
                | SyntaxKind::PLUS
                | SyntaxKind::QUESTION_MARK
                | SyntaxKind::R_BRACKET
                | SyntaxKind::R_CURLY
                | SyntaxKind::R_PAREN
                | SyntaxKind::SEMICOLON
                | SyntaxKind::SLASH
                | SyntaxKind::STAR
        )
    }
    #[doc = r" Is this [`SyntaxKind`] a keyword?"]
    #[doc = r""]
    #[doc = r" ```rust"]
    #[doc = r" # use scad_syntax::T;"]
    #[doc = r" let kind = T![function];"]
    #[doc = r" assert!(kind.is_keyword())"]
    #[doc = r" ```"]
    pub const fn is_keyword(self) -> bool {
        matches!(
            self,
            SyntaxKind::FALSE_KW
                | SyntaxKind::FILE_KW
                | SyntaxKind::FOR_KW
                | SyntaxKind::FUNCTION_KW
                | SyntaxKind::IF_KW
                | SyntaxKind::INCLUDE_KW
                | SyntaxKind::LET_KW
                | SyntaxKind::MODULE_KW
                | SyntaxKind::NUMBER_KW
                | SyntaxKind::TRUE_KW
                | SyntaxKind::UNDEF_KW
                | SyntaxKind::USE_KW
        )
    }
    #[doc = r" Given a textual symbol try to get the associated"]
    #[doc = r" [`SyntaxKind`]."]
    #[doc = r""]
    #[doc = r" # Examples"]
    #[doc = r""]
    #[doc = r" ```rust"]
    #[doc = r" # use scad_syntax::SyntaxKind;"]
    #[doc = r#" let plus = SyntaxKind::from_symbol("+").unwrap();"#]
    #[doc = r" assert_eq!(plus, SyntaxKind::PLUS);"]
    #[doc = r" ```"]
    pub fn from_symbol(symbol: &str) -> Option<Self> {
        match symbol {
            "&&" => Some(SyntaxKind::AND),
            "!" => Some(SyntaxKind::BANG),
            "^" => Some(SyntaxKind::CARET),
            ":" => Some(SyntaxKind::COLON),
            "," => Some(SyntaxKind::COMMA),
            "." => Some(SyntaxKind::DOT),
            "=" => Some(SyntaxKind::EQUALS),
            ">" => Some(SyntaxKind::GREATER_THAN),
            ">=" => Some(SyntaxKind::GREATER_THAN_EQUALS),
            "<" => Some(SyntaxKind::LESS_THAN),
            "<=" => Some(SyntaxKind::LESS_THAN_EQUALS),
            "[" => Some(SyntaxKind::L_BRACKET),
            "{" => Some(SyntaxKind::L_CURLY),
            "(" => Some(SyntaxKind::L_PAREN),
            "-" => Some(SyntaxKind::MINUS),
            "||" => Some(SyntaxKind::OR),
            "%" => Some(SyntaxKind::PERCENT),
            "+" => Some(SyntaxKind::PLUS),
            "?" => Some(SyntaxKind::QUESTION_MARK),
            "]" => Some(SyntaxKind::R_BRACKET),
            "}" => Some(SyntaxKind::R_CURLY),
            ")" => Some(SyntaxKind::R_PAREN),
            ";" => Some(SyntaxKind::SEMICOLON),
            "/" => Some(SyntaxKind::SLASH),
            "*" => Some(SyntaxKind::STAR),
            _ => None,
        }
    }
    #[doc = r" get the [`SyntaxKind`] that corresponds to a particular"]
    #[doc = r" variant."]
    #[doc = r""]
    #[doc = r" ```rust"]
    #[doc = r" # use scad_syntax::SyntaxKind;"]
    #[doc = r" let kind = SyntaxKind::IDENT;"]
    #[doc = r" let code: u16 = kind.into();"]
    #[doc = r""]
    #[doc = r" let round_tripped = SyntaxKind::from_code(code).unwrap();"]
    #[doc = r""]
    #[doc = r" assert_eq!(round_tripped, kind);"]
    #[doc = r" ```"]
    pub fn from_code(n: u16) -> Option<Self> {
        <SyntaxKind as num_traits::FromPrimitive>::from_u16(n)
    }
}
impl From<rowan::SyntaxKind> for SyntaxKind {
    fn from(k: rowan::SyntaxKind) -> Self {
        SyntaxKind::from_code(k.0).unwrap()
    }
}
impl From<SyntaxKind> for rowan::SyntaxKind {
    fn from(k: SyntaxKind) -> Self {
        rowan::SyntaxKind(k.into())
    }
}
impl From<SyntaxKind> for u16 {
    fn from(k: SyntaxKind) -> Self {
        k as u16
    }
}
impl From<SyntaxKind> for m_lexer::TokenKind {
    fn from(k: SyntaxKind) -> m_lexer::TokenKind {
        m_lexer::TokenKind(k.into())
    }
}
macro_rules! T {
    (&&) => {
        $crate::SyntaxKind::AND
    };
    (!) => {
        $crate::SyntaxKind::BANG
    };
    (^) => {
        $crate::SyntaxKind::CARET
    };
    (:) => {
        $crate::SyntaxKind::COLON
    };
    (,) => {
        $crate::SyntaxKind::COMMA
    };
    (.) => {
        $crate::SyntaxKind::DOT
    };
    (=) => {
        $crate::SyntaxKind::EQUALS
    };
    (false) => {
        $crate::SyntaxKind::FALSE_KW
    };
    (file) => {
        $crate::SyntaxKind::FILE_KW
    };
    (for) => {
        $crate::SyntaxKind::FOR_KW
    };
    (function) => {
        $crate::SyntaxKind::FUNCTION_KW
    };
    (>) => {
        $crate::SyntaxKind::GREATER_THAN
    };
    (>=) => {
        $crate::SyntaxKind::GREATER_THAN_EQUALS
    };
    (if) => {
        $crate::SyntaxKind::IF_KW
    };
    (include) => {
        $crate::SyntaxKind::INCLUDE_KW
    };
    (<) => {
        $crate::SyntaxKind::LESS_THAN
    };
    (<=) => {
        $crate::SyntaxKind::LESS_THAN_EQUALS
    };
    (let) => {
        $crate::SyntaxKind::LET_KW
    };
    ("[") => {
        $crate::SyntaxKind::L_BRACKET
    };
    ("{") => {
        $crate::SyntaxKind::L_CURLY
    };
    ("(") => {
        $crate::SyntaxKind::L_PAREN
    };
    (-) => {
        $crate::SyntaxKind::MINUS
    };
    (module) => {
        $crate::SyntaxKind::MODULE_KW
    };
    (number) => {
        $crate::SyntaxKind::NUMBER_KW
    };
    (||) => {
        $crate::SyntaxKind::OR
    };
    (%) => {
        $crate::SyntaxKind::PERCENT
    };
    (+) => {
        $crate::SyntaxKind::PLUS
    };
    (?) => {
        $crate::SyntaxKind::QUESTION_MARK
    };
    ("]") => {
        $crate::SyntaxKind::R_BRACKET
    };
    ("}") => {
        $crate::SyntaxKind::R_CURLY
    };
    (")") => {
        $crate::SyntaxKind::R_PAREN
    };
    (;) => {
        $crate::SyntaxKind::SEMICOLON
    };
    (/) => {
        $crate::SyntaxKind::SLASH
    };
    (*) => {
        $crate::SyntaxKind::STAR
    };
    (true) => {
        $crate::SyntaxKind::TRUE_KW
    };
    (undef) => {
        $crate::SyntaxKind::UNDEF_KW
    };
    (use) => {
        $crate::SyntaxKind::USE_KW
    };
}
