// Generated by `scad-codegen`. DO NOT EDIT!

#[doc = r" The different types of terminals and non-terminals in the"]
#[doc = r" OpenSCAD language grammar."]
#[allow(bad_style)]
#[derive(
    Debug,
    Copy,
    Clone,
    PartialEq,
    Eq,
    Hash,
    PartialOrd,
    Ord,
    num_derive :: FromPrimitive,
    num_derive :: ToPrimitive,
)]
#[repr(u16)]
#[non_exhaustive]
pub enum SyntaxKind {
    #[doc = "An identifier."]
    IDENT,
    #[doc = "A lexer error."]
    ERROR,
    #[doc = "One or more whitespace characters (spaces, tabs, newlines, etc.)."]
    WHITESPACE,
    #[doc = "A comment."]
    COMMENT,
    #[doc = "An integer literal"]
    INTEGER_LIT,
    #[doc = "A float literal"]
    FLOAT_LIT,
    #[doc = "A string literal"]
    STRING_LIT,
    #[doc = "The `!` symbol."]
    BANG,
    #[doc = "The `%` symbol."]
    PERCENT,
    #[doc = "The `&&` symbol."]
    AND,
    #[doc = "The `(` symbol."]
    L_PAREN,
    #[doc = "The `)` symbol."]
    R_PAREN,
    #[doc = "The `*` symbol."]
    STAR,
    #[doc = "The `+` symbol."]
    PLUS,
    #[doc = "The `,` symbol."]
    COMMA,
    #[doc = "The `-` symbol."]
    MINUS,
    #[doc = "The `/` symbol."]
    SLASH,
    #[doc = "The `:` symbol."]
    COLON,
    #[doc = "The `;` symbol."]
    SEMICOLON,
    #[doc = "The `<` symbol."]
    LESS_THAN,
    #[doc = "The `<=` symbol."]
    LESS_THAN_EQUALS,
    #[doc = "The `=` symbol."]
    EQUALS,
    #[doc = "The `>` symbol."]
    GREATER_THAN,
    #[doc = "The `>=` symbol."]
    GREATER_THAN_EQUALS,
    #[doc = "The `?` symbol."]
    QUESTION_MARK,
    #[doc = "The `[` symbol."]
    L_BRACKET,
    #[doc = "The `]` symbol."]
    R_BRACKET,
    #[doc = "The `{` symbol."]
    L_CURLY,
    #[doc = "The `||` symbol."]
    OR,
    #[doc = "The `}` symbol."]
    R_CURLY,
    #[doc = "The `false` keyword."]
    FALSE_KW,
    #[doc = "The `file` keyword."]
    FILE_KW,
    #[doc = "The `for` keyword."]
    FOR_KW,
    #[doc = "The `function` keyword."]
    FUNCTION_KW,
    #[doc = "The `if` keyword."]
    IF_KW,
    #[doc = "The `include` keyword."]
    INCLUDE_KW,
    #[doc = "The `let` keyword."]
    LET_KW,
    #[doc = "The `module` keyword."]
    MODULE_KW,
    #[doc = "The `number` keyword."]
    NUMBER_KW,
    #[doc = "The `string` keyword."]
    STRING_KW,
    #[doc = "The `true` keyword."]
    TRUE_KW,
    #[doc = "The `undef` keyword."]
    UNDEF_KW,
    #[doc = "The `use` keyword."]
    USE_KW,
    PACKAGE,
    INCLUDE,
    USE,
    ASSIGNMENT,
    NAMED_FUNCTION_DEFINITION,
    NAMED_MODULE_DEFINITION,
    MODULE_INSTANTIATION,
    EXPRESSIONS,
    LIST_EXPRESSION,
    BIN_EXPR,
    UNARY_EXPR,
    TERNARY_EXPR,
    INDEX_EXPR,
    PAREN_EXPR,
    LIST_COMPREHENSION_EXPR,
    LET_CLAUSE,
    FUNCTION_CALL,
    RANGE_EXPRESSION_FROM_TO,
    RANGE_EXPRESSION_FROM_TO_STEP,
    FOR_CLAUSE,
    IF_CLAUSE,
    ASSIGNMENTS_OPT,
    ASSIGNMENTS,
    PARAMETERS,
    ARGUMENTS,
    CHILDREN,
    BRACED_CHILDREN,
}
impl SyntaxKind {
    #[doc = r" Is this [`SyntaxKind`] a piece of punctuation?"]
    #[doc = r""]
    #[doc = r" ```rust"]
    #[doc = r" # use scad_syntax::T;"]
    #[doc = r" let kind = T![;];"]
    #[doc = r" assert!(kind.is_punctuation())"]
    #[doc = r" ```"]
    pub const fn is_punctuation(self) -> bool {
        match self {
            SyntaxKind::BANG
            | SyntaxKind::PERCENT
            | SyntaxKind::AND
            | SyntaxKind::L_PAREN
            | SyntaxKind::R_PAREN
            | SyntaxKind::STAR
            | SyntaxKind::PLUS
            | SyntaxKind::COMMA
            | SyntaxKind::MINUS
            | SyntaxKind::SLASH
            | SyntaxKind::COLON
            | SyntaxKind::SEMICOLON
            | SyntaxKind::LESS_THAN
            | SyntaxKind::LESS_THAN_EQUALS
            | SyntaxKind::EQUALS
            | SyntaxKind::GREATER_THAN
            | SyntaxKind::GREATER_THAN_EQUALS
            | SyntaxKind::QUESTION_MARK
            | SyntaxKind::L_BRACKET
            | SyntaxKind::R_BRACKET
            | SyntaxKind::L_CURLY
            | SyntaxKind::OR
            | SyntaxKind::R_CURLY => true,
            _ => false,
        }
    }
    #[doc = r" Is this [`SyntaxKind`] a keyword?"]
    #[doc = r""]
    #[doc = r" ```rust"]
    #[doc = r" # use scad_syntax::T;"]
    #[doc = r" let kind = T![function];"]
    #[doc = r" assert!(kind.is_keyword())"]
    #[doc = r" ```"]
    pub const fn is_keyword(self) -> bool {
        match self {
            SyntaxKind::FALSE_KW
            | SyntaxKind::FILE_KW
            | SyntaxKind::FOR_KW
            | SyntaxKind::FUNCTION_KW
            | SyntaxKind::IF_KW
            | SyntaxKind::INCLUDE_KW
            | SyntaxKind::LET_KW
            | SyntaxKind::MODULE_KW
            | SyntaxKind::NUMBER_KW
            | SyntaxKind::STRING_KW
            | SyntaxKind::TRUE_KW
            | SyntaxKind::UNDEF_KW
            | SyntaxKind::USE_KW => true,
            _ => false,
        }
    }
    #[doc = r" Given a textual symbol try to get the associated"]
    #[doc = r" [`SyntaxKind`]."]
    #[doc = r""]
    #[doc = r" # Examples"]
    #[doc = r""]
    #[doc = r" ```rust"]
    #[doc = r" # use scad_syntax::SyntaxKind;"]
    #[doc = r#" let plus = SyntaxKind::from_symbol("+").unwrap();"#]
    #[doc = r" assert_eq!(plus, SyntaxKind::PLUS);"]
    #[doc = r" ```"]
    pub fn from_symbol(symbol: &str) -> Option<Self> {
        match symbol {
            "!" => Some(SyntaxKind::BANG),
            "%" => Some(SyntaxKind::PERCENT),
            "&&" => Some(SyntaxKind::AND),
            "(" => Some(SyntaxKind::L_PAREN),
            ")" => Some(SyntaxKind::R_PAREN),
            "*" => Some(SyntaxKind::STAR),
            "+" => Some(SyntaxKind::PLUS),
            "," => Some(SyntaxKind::COMMA),
            "-" => Some(SyntaxKind::MINUS),
            "/" => Some(SyntaxKind::SLASH),
            ":" => Some(SyntaxKind::COLON),
            ";" => Some(SyntaxKind::SEMICOLON),
            "<" => Some(SyntaxKind::LESS_THAN),
            "<=" => Some(SyntaxKind::LESS_THAN_EQUALS),
            "=" => Some(SyntaxKind::EQUALS),
            ">" => Some(SyntaxKind::GREATER_THAN),
            ">=" => Some(SyntaxKind::GREATER_THAN_EQUALS),
            "?" => Some(SyntaxKind::QUESTION_MARK),
            "[" => Some(SyntaxKind::L_BRACKET),
            "]" => Some(SyntaxKind::R_BRACKET),
            "{" => Some(SyntaxKind::L_CURLY),
            "||" => Some(SyntaxKind::OR),
            "}" => Some(SyntaxKind::R_CURLY),
            _ => None,
        }
    }
    #[doc = r" get the [`SyntaxKind`] that corresponds to a particular"]
    #[doc = r" variant."]
    #[doc = r""]
    #[doc = r" ```rust"]
    #[doc = r" # use scad_syntax::SyntaxKind;"]
    #[doc = r" let kind = SyntaxKind::IDENT;"]
    #[doc = r" let code: u16 = kind.into();"]
    #[doc = r""]
    #[doc = r" let round_tripped = SyntaxKind::from_code(code).unwrap();"]
    #[doc = r""]
    #[doc = r" assert_eq!(round_tripped, kind);"]
    #[doc = r" ```"]
    pub fn from_code(n: u16) -> Option<Self> {
        <SyntaxKind as num_traits::FromPrimitive>::from_u16(n)
    }
}
impl From<rowan::SyntaxKind> for SyntaxKind {
    fn from(k: rowan::SyntaxKind) -> Self {
        SyntaxKind::from_code(k.0).unwrap()
    }
}
impl From<SyntaxKind> for rowan::SyntaxKind {
    fn from(k: SyntaxKind) -> Self {
        rowan::SyntaxKind(k.into())
    }
}
impl From<SyntaxKind> for u16 {
    fn from(k: SyntaxKind) -> Self {
        k as u16
    }
}
impl From<SyntaxKind> for m_lexer::TokenKind {
    fn from(k: SyntaxKind) -> m_lexer::TokenKind {
        m_lexer::TokenKind(k.into())
    }
}
#[doc = r" A helper macro for getting the [`SyntaxKind`] that corresponds"]
#[doc = r" to a particular token."]
#[macro_export]
macro_rules! T {
    (false) => {
        $crate::SyntaxKind::FALSE_KW
    };
    (file) => {
        $crate::SyntaxKind::FILE_KW
    };
    (for) => {
        $crate::SyntaxKind::FOR_KW
    };
    (function) => {
        $crate::SyntaxKind::FUNCTION_KW
    };
    (if) => {
        $crate::SyntaxKind::IF_KW
    };
    (include) => {
        $crate::SyntaxKind::INCLUDE_KW
    };
    (let) => {
        $crate::SyntaxKind::LET_KW
    };
    (module) => {
        $crate::SyntaxKind::MODULE_KW
    };
    (number) => {
        $crate::SyntaxKind::NUMBER_KW
    };
    (string) => {
        $crate::SyntaxKind::STRING_KW
    };
    (true) => {
        $crate::SyntaxKind::TRUE_KW
    };
    (undef) => {
        $crate::SyntaxKind::UNDEF_KW
    };
    (use) => {
        $crate::SyntaxKind::USE_KW
    };
    (!) => {
        $crate::SyntaxKind::BANG
    };
    (%) => {
        $crate::SyntaxKind::PERCENT
    };
    (&&) => {
        $crate::SyntaxKind::AND
    };
    ("(") => {
        $crate::SyntaxKind::L_PAREN
    };
    (")") => {
        $crate::SyntaxKind::R_PAREN
    };
    (*) => {
        $crate::SyntaxKind::STAR
    };
    (+) => {
        $crate::SyntaxKind::PLUS
    };
    (,) => {
        $crate::SyntaxKind::COMMA
    };
    (-) => {
        $crate::SyntaxKind::MINUS
    };
    (/) => {
        $crate::SyntaxKind::SLASH
    };
    (:) => {
        $crate::SyntaxKind::COLON
    };
    (;) => {
        $crate::SyntaxKind::SEMICOLON
    };
    (<) => {
        $crate::SyntaxKind::LESS_THAN
    };
    (<=) => {
        $crate::SyntaxKind::LESS_THAN_EQUALS
    };
    (=) => {
        $crate::SyntaxKind::EQUALS
    };
    (>) => {
        $crate::SyntaxKind::GREATER_THAN
    };
    (>=) => {
        $crate::SyntaxKind::GREATER_THAN_EQUALS
    };
    (?) => {
        $crate::SyntaxKind::QUESTION_MARK
    };
    ("[") => {
        $crate::SyntaxKind::L_BRACKET
    };
    ("]") => {
        $crate::SyntaxKind::R_BRACKET
    };
    ("{") => {
        $crate::SyntaxKind::L_CURLY
    };
    (||) => {
        $crate::SyntaxKind::OR
    };
    ("}") => {
        $crate::SyntaxKind::R_CURLY
    };
}
