use std::{fs::File, path::PathBuf};

use anyhow::{Context, Error};
use clap::Parser;
use scad_bytecode::{Chunk, Constant, Instruction, Program};

fn main() -> Result<(), Error> {
    let Args { output } = Args::from_args();

    // A program that looks like:
    //   x = "Hello, World";
    //   y = 42.0;
    //  return -y;
    let program = Program {
        chunk: Chunk {
            constants: vec![Constant::string("Hello, World!"), Constant::number(42.0)],
            instructions: vec![
                Instruction::Constant(0),
                Instruction::Constant(1),
                Instruction::Negate,
                Instruction::Return,
            ],
            line_numbers: vec![0, 1, 2, 2],
        },
    };

    match output {
        Some(filename) => {
            let f = File::create(&filename).with_context(|| {
                format!("Unable to open for \"{}\" for writing", filename.display())
            })?;
            program.serialize(f)?;
            Ok(())
        }
        None => {
            program.serialize(std::io::stdout())?;
            Ok(())
        }
    }
}

#[derive(Parser)]
struct Args {
    /// Where to write the generated bytecode to (stdout by default)
    output: Option<PathBuf>,
}
