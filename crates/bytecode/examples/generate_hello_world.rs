use std::{fs::File, path::PathBuf};

use anyhow::{Context, Error};
use clap::Parser;
use scad_bytecode::{Chunk, Constant, Instruction, Program};

fn main() -> Result<(), Error> {
    let Args { output } = Args::from_args();

    // A program that looks like:
    //   return -((1.2 + 3.4) / 5.6);
    let mut chunk = Chunk::empty();
    let a = chunk.push_constant(Constant::number(1.2));
    chunk.push_instruction(Instruction::Constant(a), 0);
    let b = chunk.push_constant(Constant::number(3.4));
    chunk.push_instruction(Instruction::Constant(b), 0);

    chunk.push_instruction(Instruction::Add, 0);

    let c = chunk.push_constant(Constant::number(5.6));
    chunk.push_instruction(Instruction::Constant(c), 0);

    chunk.push_instruction(Instruction::Div, 0);
    chunk.push_instruction(Instruction::Negate, 0);
    chunk.push_instruction(Instruction::Return, 0);

    let program = Program { chunk };

    match output {
        Some(filename) => {
            let f = File::create(&filename).with_context(|| {
                format!("Unable to open for \"{}\" for writing", filename.display())
            })?;
            program.serialize(f)?;
            Ok(())
        }
        None => {
            program.serialize(std::io::stdout())?;
            Ok(())
        }
    }
}

#[derive(Parser)]
struct Args {
    /// Where to write the generated bytecode to (stdout by default)
    output: Option<PathBuf>,
}
